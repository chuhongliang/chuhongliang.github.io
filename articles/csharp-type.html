<!doctype html>
<html>
    <head>
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"/>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
        <meta name="description" content="Content of description meta tag"/>
        <meta name="keywords" content="keyword1,keyword2,keyword3"/>
        <meta name="author" content="Content of author meta tag"/>
        <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
        <title>chuhongliang.github.io - C# 类型和变量
</title>
        <link rel="stylesheet" href="/assets/vendor/normalize.css"/>
        <link rel="stylesheet" href="/assets/vendor/prettify-night.css"/>
        <link rel="stylesheet" href="/assets/themes/default/main.css"/>
        <link rel="shortcut icon" href="/fav.ico"/>
        <script type="text/javascript" src="/assets/vendor/prettify.js"></script>
        
    </head>
    <body onload="prettyPrint()">
    <div id="header">
        <div id="header-inner">
            <div id="title"><a href="/">chuhongliang.github.io</a></div>
            <div id="subtitle">learn coding, keep coding</div>
        </div>
    </div>

<div id="main">
    <div id="main-inner">
        <div id="topnav">
            <ul>
                <li><a href="/">首页</a></li>
                <li class="sep"> | </li>
                <li><a href="/tag.html">标签</a></li>
                
<li class="sep"> | </li>
<li><a href="/pages/about-me.html" target="_self">关于我</a></li>

<li class="sep"> | </li>
<li><a href="https://github.com/chuhongliang" target="_blank">github</a></li>


            </ul>
            <div style="clear:both;"></div>
        </div>
        <div id="article-title">
            <a href="/articles/csharp-type.html">C# 类型和变量</a>
        </div>
        <div id="article-meta">
            作者 chuhongliang | 发布于 2020-05-26
        </div>
        <div id="article-tags">
        
        <a class="tag" href="/tag.html#C#">C#</a>
        
        </div>
        <div id="article-content">
            <h1 id="c-类型和变量">C# 类型和变量</h1>
<p>C# 有两种类型：值类型和引用类型。 值类型的变量直接包含数据，而引用类型的变量则存储对数据（称为“对象”）的引用。 对于引用类型，两个变量可以引用同一对象；因此，对一个变量执行的运算可能会影响另一个变量引用的对象。 借助值类型，每个变量都有自己的数据副本；因此，对一个变量执行的运算不会影响另一个变量（ref 和 out 参数变量除外）。</p>
<p>C# 值类型又细分为简单类型、枚举类型、结构类型和可以为 null 的值类型。 C# 引用类型又细分为类类型、接口类型、数组类型和委托类型。</p>
<h1 id="以下大纲概述了-c-的类型系统。">以下大纲概述了 C# 的类型系统。</h1>
<ul>
<li>值类型<ul>
<li>简单类型<ul>
<li>有符号的整型：sbyte、short、int、long</li>
<li>无符号的整型：byte、ushort、uint、ulong</li>
<li>Unicode 字符：char</li>
<li>IEEE 二进制浮点：float、double</li>
<li>高精度十进制浮点数：decimal</li>
<li>布尔：bool</li>
</ul>
</li>
<li>枚举类型<ul>
<li>格式为 enum E {...} 的用户定义类型</li>
</ul>
</li>
<li>结构类型<ul>
<li>格式为 struct S {...} 的用户定义类型</li>
</ul>
</li>
<li>可以为 null 的值类型<ul>
<li>值为 null 的其他所有值类型的扩展</li>
</ul>
</li>
<li>元组值类型<ul>
<li>格式为 (T1, T2, ...) 的用户定义类型</li>
</ul>
</li>
</ul>
</li>
<li>引用类型<ul>
<li>类类型<ul>
<li>其他所有类型的最终基类：object</li>
<li>Unicode 字符串：string</li>
<li>格式为 class C {...} 的用户定义类型</li>
</ul>
</li>
<li>接口类型<ul>
<li>格式为 interface I {...} 的用户定义类型</li>
</ul>
</li>
<li>数组类型<ul>
<li>一维和多维，例如 int[] 和 int[,]</li>
</ul>
</li>
<li>委托类型<ul>
<li>格式为 delegate int D(...) 的用户定义类型</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>C# 的 bool 类型用于表示布尔值（true 或 false）。</p>
<p>C# 使用 Unicode 编码处理字符和字符串。 char 类型表示 UTF-16 代码单元，string 类型表示一系列 UTF-16 代码单元。</p>
<p>C# 程序使用类型声明创建新类型。 类型声明指定新类型的名称和成员。 用户可定义以下五种 C# 类型：类类型、结构类型、接口类型、枚举类型和委托类型。</p>
<p>class 类型定义包含数据成员（字段）和函数成员（方法、属性及其他）的数据结构。 类类型支持单一继承和多形性，即派生类可以扩展和专门针对基类的机制。</p>
<p>struct 类型定义包含数据成员和函数成员的结构，这一点与类类型相似。 不过，与类不同的是，结构是值类型，通常不需要进行堆分配。 结构类型不支持用户指定的继承，并且所有结构类型均隐式继承自类型 object。</p>
<p>interface 类型将协定定义为一组已命名的公共函数成员。 实现 interface 的 class 或 struct 必须提供接口函数成员的实现代码。 interface 可以继承自多个基接口，class 和 struct 可以实现多个接口。</p>
<p>delegate 类型表示引用包含特定参数列表和返回类型的方法。 通过委托，可以将方法视为可分配给变量并可作为参数传递的实体。 委托类同于函数式语言提供的函数类型。 它们还类似于其他一些语言中存在的“函数指针”概念。 与函数指针不同，委托是面向对象且类型安全的。</p>
<p>class、struct、interface 和 delegate 类型全部都支持泛型，因此可以使用其他类型对它们进行参数化。</p>
<p>enum 类型是一种包含已命名常量的独特类型。 每个 enum 类型都有一个基础类型（必须是八种整型类型之一）。 enum 类型的值集与基础类型的值集相同。</p>
<p>C# 支持任意类型的一维和多维数组。 与上述类型不同，数组类型无需先声明即可使用。 相反，数组类型是通过在类型名称后面添加方括号构造而成。 例如，int[] 是 int 类型的一维数组，int[,] 是 int 类型的二维数组，int[][] 是由 int 类型的一维数组构成的一维数组。</p>
<p>可以为 null 的值类型也无需先声明即可使用。 对于所有不可以为 null 的值类型 T，都有对应的可以为 null 的值类型 T?，后者可以包含附加值 null。 例如，int? 是可以包含任何 32 位整数或值 null 的类型。</p>
<p>C# 采用统一的类型系统，因此任意类型的值都可视为 object。 每种 C# 类型都直接或间接地派生自 object 类类型，而 object 是所有类型的最终基类。 只需将值视为类型 object，即可将引用类型的值视为对象。 通过执行装箱和取消装箱操作，可以将值类型的值视为对象。 在以下示例中，int 值被转换成 object，然后又恢复成 int。</p>
<pre class="prettyprint linenums lang-C#">using System;
class BoxingExample
{
    static void Main()
    {
        int i = 123;
        object o = i;    // Boxing
        int j = (int)o;  // Unboxing
    }
}
</pre>
<p>将值类型的值分配给 object 对象引用时，会分配一个“箱”来保存此值。 该箱是引用类型的实例，此值会被复制到该箱。 相反，当 object 引用被显式转换成值类型时，将检查引用的 object 是否是具有正确值类型的箱。 如果检查成功，则会将箱中的值复制到值类型。</p>
<p>C# 的统一类型系统实际上意味着“按需”将值类型视为 object 引用。 鉴于这种统一性，使用类型 object 的常规用途库可以与派生自 object 的所有类型结合使用，包括引用类型和值类型。</p>
<h1 id="c-变量">C# 变量</h1>
<p>C# 有多种变量，其中包括字段、数组元素、局部变量和参数。 变量表示存储位置，每个变量都具有一种类型，用于确定可以在变量中存储哪些值，如下文所述。</p>
<ul>
<li>不可以为 null 的值类型<ul>
<li>具有精确类型的值</li>
</ul>
</li>
<li>可以为 null 的值类型<ul>
<li>null 值或具有精确类型的值</li>
</ul>
</li>
<li>object<ul>
<li>null 引用、对任意引用类型的对象的引用，或对任意值类型的装箱值的引用</li>
</ul>
</li>
<li>类类型<ul>
<li>null 引用、对类类型实例的引用，或对派生自类类型的类实例的引用</li>
</ul>
</li>
<li>接口类型<ul>
<li>null 引用、对实现接口类型的类类型实例的引用，或对实现接口类型的值类型的装箱值的引用</li>
</ul>
</li>
<li>数组类型<ul>
<li>null 引用、对数组类型实例的引用，或对兼容的数组类型实例的引用</li>
</ul>
</li>
<li>委托类型<ul>
<li>null 引用或对兼容的委托类型实例的引用</li>
</ul>
</li>
</ul>
<h2 id="局部变量声明">局部变量声明</h2>
<pre class="prettyprint linenums lang-C#">static void Declarations(string[] args)
{
    int a;
    int b = 2, c = 3;
    a = 1;
    Console.WriteLine(a + b + c);
}
</pre>
<h2 id="局部常量声明">局部常量声明</h2>
<pre class="prettyprint linenums lang-C#">static void ConstantDeclarations(string[] args)
{
    const float pi = 3.1415927f;
    const int r = 25;
    Console.WriteLine(pi * r * r);
}
</pre>

        </div>
        
    </div>
</div>
        <div id="footer">
            <div id="footer-inner">
                <p id="copyright">Copyright (c) 2019-至今 Copyrighter</p>
            </div>
        </div>
        <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [['$','$'], ['\\(','\\)']],
            processEscapes: true
        }
    });
</script>
<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>

    </body>
</html>

