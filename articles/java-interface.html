<!doctype html>
<html>
    <head>
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"/>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
        <meta name="description" content="Content of description meta tag"/>
        <meta name="keywords" content="keyword1,keyword2,keyword3"/>
        <meta name="author" content="Content of author meta tag"/>
        <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
        <title>chuhongliang.github.io - Java 接口和抽象类
</title>
        <link rel="stylesheet" href="/assets/vendor/normalize.css"/>
        <link rel="stylesheet" href="/assets/vendor/prettify-night.css"/>
        <link rel="stylesheet" href="/assets/themes/default/main.css"/>
        <link rel="shortcut icon" href="/fav.ico"/>
        <script type="text/javascript" src="/assets/vendor/prettify.js"></script>
        
    </head>
    <body onload="prettyPrint()">
    <div id="header">
        <div id="header-inner">
            <div id="title"><a href="/">chuhongliang.github.io</a></div>
            <div id="subtitle">learn coding, keep coding</div>
        </div>
    </div>

<div id="main">
    <div id="main-inner">
        <div id="topnav">
            <ul>
                <li><a href="/">首页</a></li>
                <li class="sep"> | </li>
                <li><a href="/tag.html">标签</a></li>
                
<li class="sep"> | </li>
<li><a href="/pages/about-me.html" target="_self">关于我</a></li>

<li class="sep"> | </li>
<li><a href="https://github.com/chuhongliang" target="_blank">github</a></li>


            </ul>
            <div style="clear:both;"></div>
        </div>
        <div id="article-title">
            <a href="/articles/java-interface.html">Java 接口和抽象类</a>
        </div>
        <div id="article-meta">
            作者 chuhongliang | 发布于 2020-02-07
        </div>
        <div id="article-tags">
        
        <a class="tag" href="/tag.html#Java">Java</a>
        
        </div>
        <div id="article-content">
            <h3 id="对于面向对象编程来说，抽象是它的一大特征之一。在-java-中，可以通过两种形式来体现-oop-的抽象：接口和抽象类。">对于面向对象编程来说，抽象是它的一大特征之一。在 Java 中，可以通过两种形式来体现 OOP 的抽象：接口和抽象类。</h3>
<hr>
<h2 id="一、抽象类">一、抽象类</h2>
<p>如果一个类含有抽象方法，则称这个类为抽象类，抽象类必须在类前用 abstract 关键字修饰。因为抽象类中含有无具体实现的方法，所以不能用抽象类创建对象。</p>
<p>包含抽象方法的类称为抽象类，但并不意味着抽象类中只能有抽象方法，它和普通类一样，同样可以拥有成员变量和普通的成员方法。注意，抽象类和普通类的主要有三点区别：</p>
<ol>
<li>抽象方法必须为 public 或者 protected（因为如果为 private，则不能被子类继承，子类便无法实现该方法），默认情况下默认为 public。</li>
<li>抽象类不能用来创建对象；</li>
<li>如果一个类继承于一个抽象类，则子类必须实现父类的抽象方法。如果子类没有实现父类的抽象方法，则必须将子类也定义为为 abstract 类。
在其他方面，抽象类和普通的类并没有区别。</li>
</ol>
<hr>
<h2 id="二、接口">二、接口</h2>
<p>接口，英文称作 interface，在软件工程中，接口泛指供别人调用的方法或者函数。从这里，我们可以体会到 Java 语言设计者的初衷，它是对行为的抽象。</p>
<p>在 Java 中，定一个接口的形式如下：</p>
<pre class="prettyprint linenums lang-java">public interface InterfaceName{

}
</pre>
<p>接口中可以含有 变量和方法。但是要注意，接口中的变量会被隐式地指定为 public static final 变量（并且只能是 public static final变量，用 private 修饰会报编译错误），而方法会被隐式地指定为 public abstract 方法且只能是 public abstract 方法（用其他关键字，比如 private、protected、static、 final 等修饰会报编译错误），并且接口中所有的方法不能有具体的实现，也就是说，接口中的方法必须都是抽象方法。从这里可以隐约看出接口和抽象类的区别，接口是一种极度抽象的类型，它比抽象类更加&quot;抽象&quot;，并且一般情况下不在接口中定义变量。
要让一个类遵循某组特地的接口需要使用 implements 关键字，具体格式如下：</p>
<pre class="prettyprint linenums lang-java">class ClassName implements Interface1,Interface2,[....]{

}
</pre>
<p>可以看出，允许一个类遵循多个特定的接口。如果一个非抽象类遵循了某个接口，就必须实现该接口中的所有方法。对于遵循某个接口的抽象类，可以不实现该接口中的抽象方法。</p>
<h2 id="抽象类和接口的区别">抽象类和接口的区别</h2>
<h3 id="1、语法层面上的区别">1、语法层面上的区别</h3>
<ul>
<li>抽象类可以提供成员方法的实现细节，而接口中只能存在public abstract 方法；</li>
<li>抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是public static final类型的；</li>
<li>接口中不能含有静态代码块以及静态方法，而抽象类可以有静态代码块和静态方法；</li>
<li>一个类只能继承一个抽象类，而一个类却可以实现多个接口。</li>
</ul>
<h3 id="2、设计层面上的区别">2、设计层面上的区别</h3>
<ul>
<li>抽象类是对一种事物的抽象，即对类抽象，而接口是对行为的抽象。抽象类是对整个类整体进行抽象，包括属性、行为，但是接口却是对类局部（行为）进行抽象。举个简单的例子，飞机和鸟是不同类的事物，但是它们都有一个共性，就是都会飞。那么在设计的时候，可以将飞机设计为一个类 Airplane，将鸟设计为一个类 Bird，但是不能将 飞行 这个特性也设计为类，因此它只是一个行为特性，并不是对一类事物的抽象描述。此时可以将 飞行 设计为一个接口Fly，包含方法fly( )，然后Airplane和Bird分别根据自己的需要实现Fly这个接口。然后至于有不同种类的飞机，比如战斗机、民用飞机等直接继承Airplane即可，对于鸟也是类似的，不同种类的鸟直接继承Bird类即可。从这里可以看出，继承是一个 &quot;是不是&quot;的关系，而 接口 实现则是 &quot;有没有&quot;的关系。如果一个类继承了某个抽象类，则子类必定是抽象类的种类，而接口实现则是有没有、具备不具备的关系，比如鸟是否能飞（或者是否具备飞行这个特点），能飞行则可以实现这个接口，不能飞行就不实现这个接口。</li>
<li>设计层面不同，抽象类作为很多子类的父类，它是一种模板式设计。而接口是一种行为规范，它是一种辐射式设计。什么是模板式设计？最简单例子，大家都用过 ppt 里面的模板，如果用模板 A 设计了 ppt B 和 ppt C，ppt B 和 ppt C 公共的部分就是模板 A 了，如果它们的公共部分需要改动，则只需要改动模板 A 就可以了，不需要重新对 ppt B 和 ppt C 进行改动。而辐射式设计，比如某个电梯都装了某种报警器，一旦要更新报警器，就必须全部更新。也就是说对于抽象类，如果需要添加新的方法，可以直接在抽象类中添加具体的实现，子类可以不进行变更；而对于接口则不行，如果接口进行了变更，则所有实现这个接口的类都必须进行相应的改动。</li>
</ul>
<p>下面看一个网上流传最广泛的例子：门和警报的例子：门都有 open() 和 close() 两个动作，此时我们可以定义通过抽象类和接口来定义这个抽象概念：</p>
<pre class="prettyprint linenums lang-java">abstract class Door {
    public abstract void open();
    public abstract void close();
}
</pre>
<p>或者</p>
<pre class="prettyprint linenums lang-java">interface Door {
    public abstract void open();
    public abstract void close();
}
</pre>
<p>但是现在如果我们需要门具有报警 的功能，那么该如何实现？下面提供两种思路：</p>
<ul>
<li>将这三个功能都放在抽象类里面，但是这样一来所有继承于这个抽象类的子类都具备了报警功能，但是有的门并不一定具备报警功能。</li>
<li>将这三个功能都放在接口里面，需要用到报警功能的类就需要实现这个接口中的 open( ) 和 close( )，也许这个类根本就不具备 open( ) 和 close( ) 这两个功能，比如火灾报警器。</li>
</ul>
<p>从这里可以看出， Door 的 open() 、close() 和 alarm() 根本就属于两个不同范畴内的行为，open() 和 close() 属于门本身固有的行为特性，而 alarm() 属于延伸的附加行为。因此最好的解决办法是单独将报警设计为一个接口，包含 alarm() 行为，Door 设计为单独的一个抽象类，包含 open 和 close 两种行为。再设计一个报警门继承 Door 类和实现 Alarm 接口。</p>
<pre class="prettyprint linenums lang-java">interface Alram {
    void alarm();
}

abstract class Door {
    void open();
    void close();
}

class AlarmDoor extends Door implements Alarm {
    void oepn() {
      //....
    }
    void close() {
      //....
    }
    void alarm() {
      //....
    }
}
</pre>

        </div>
        
    </div>
</div>
        <div id="footer">
            <div id="footer-inner">
                <p id="copyright">Copyright (c) 2019-至今 Copyrighter</p>
            </div>
        </div>
        <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [['$','$'], ['\\(','\\)']],
            processEscapes: true
        }
    });
</script>
<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>

    </body>
</html>

