# MySQL 知识点
- 调优
- [索引](#索引)
- mvcc
- [存储引擎](#存储引擎)
- [事务] (#事务)
- 锁
- 日志系统
- 主从复制
- 读写分离
- 分库分表 


# MySQL Server
- 连接器: 管理连接，验证权限
- 分析器: 词法分析，语法分析
- 优化器: （用户无法控制）
  - CBO: 基于成本的优化，应该比较广泛
  - RBO: 基于规则的优化，
- 执行器: 用来跟存储引擎直接交互。

## 索引
> 1. 局部性原理：数据和程序都有聚集成群的倾向，分为空间局部性和时间局部性。
> 2. 磁盘预读：内存跟磁盘在进行交互的时候要保证每次读取数据需要一个逻辑单位，而这个逻辑单位叫做页。或者叫datapage, 一般都是4K或者8K， 在进行读取的时候一般都是4K的整数倍。
innodb每次读取16KB。 [参考资料](https://blog.csdn.net/weixin_36043375/article/details/113349291)

索引的数据结构：
- hash: memory 使用hash索引，innodb支持自适应hash索引。单行查询快，不支持范围查询
- 树: 
  - B+ 树: 
    - 多叉树
    - 节点有序
    - 每一个节点可以存储多条记录

####　mysql的索引一般有几层？
一般情况下，3到4层就足以支撑千万级别的表的查询。

#### 创建索引的字段是长了好还是短了好？
短了好，原因是在层数不变的情况下可以存储更多的数据量。

#### 创建表的时候是用代理主键还是用自然主键？
- 代理主键：跟业务无关字段（id）
- 自然主键：跟业务有关的字段（phonenumber）
能使用代理主键尽可能的使用代理主键。

####　主键设置好之后，要不要自增？
在满足业务的情况下尽可能自增，不自增会增加索引的维护成本。

####　在分布式应用场中，自增id还适用吗？
不适用，雪花算法snowflake, 自定义id生成器。


###　回表
###　索引覆盖
###　最左匹配
###　索引下推

### 聚簇索引和非聚簇索引
- 聚簇索引: 数据跟索引聚集存储的　innodb的主键索引
  - innodb的主键索引就是聚簇索引，必须要包含一个主键列的：key (直接存放数据)
  - 如果在创建表的时候制定了主键，那么key就是主键，如果没有主键，那么key就是唯一键。如果唯一键也没有，那么key就是6字节的rowID。
- 非聚簇索索引：数据跟索引不是聚集存储的
  - myisam 的所有索引
  - innodb 的二级索引(辅助索引，普通索引) (辅助索引，普通索引的叶子节点存放主键)






## 存储引擎
定义：不同的数据文件在磁盘的不同组织形式。

分类：
- innodb
- myisam
- memory(Heap)

### innodb 和 myisam 的区别
- innodb 支持事务，myisam不支持
- innodb 支持外键，myisam不支持
- innodb 支持表锁和行锁，myisam只支持表锁
- innodb 在5.6版本之后支持全文索引， myisam 一直支持全文索引
- innodb 索引的叶子节点直接存放数据（聚簇索引），myisam 存放地址（非聚簇索引: 就是索引与行数据分开存储）。




## 事务
- 原子性：undo log 　保存的是跟执行操作相反的操作，用于回滚。保证原子性，参与部分的mvcc(多版本并发控制)操作。
- 一致性：
- 隔离性：用锁来保证 
  - 读未提交：会触发脏读，幻读，不可重复读。
  - 读已提交：会触发幻读，不可重复读。  读取的是最新的一致性的快照版本。
  - 可重复读：会触发幻读　(默认级别)　　 读取的是事务开启之前的版本。
  - 串行化(序列化)：
  - 隔离级别越低，效率越高，越不安全；隔离级别越高，效率越低，越安全。
- 持久性：redo log 　为了保证 crash safe; 如果发生异常情况，就算数据没有持久化成功，只要日志持久化成功了，依然可以进行恢复。



