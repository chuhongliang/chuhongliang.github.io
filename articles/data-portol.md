# 通信中使用的数据格式
数据格式分为两大类:文本格式，二进制格式。
- 文本格式: 
    - [xml](https://www.xml.com)
    - [json](https://www.json.org/json-en.html)
- 二进制格式: 
    - [Protobuf](https://developers.google.cn/protocol-buffers/)
    - [FlatBuffers](http://google.github.io/flatbuffers/md__benchmarks.html)
    - [Thrift](https://thrift.apache.org)
    - [Avro](https://avro.apache.org)
    - [msgpack](https://msgpack.org)
    - [Cap'n Proto](https://capnproto.org/encoding.html)

## XML定义
扩展标记语言 (Extensible Markup Language, XML) ，用于标记电子文件使其具有结构性的标记语言，可以用来标记数据、定义数据类型，是一种允许用户对自己的标记语言进行定义的源语言。 XML使用DTD(document type definition)文档类型定义来组织数据;格式统一，跨平台和语言，早已成为业界公认的标准。
XML是标准通用标记语言 (SGML) 的子集，非常适合 Web 传输。XML 提供统一的方法来描述和交换独立于应用程序或供应商的结构化数据。

## XML的优缺点
 1. XML的优点
    - 格式统一，符合标准；
    - 容易与其他系统进行远程交互，数据共享比较方便。
 1. XML的缺点
    - XML文件庞大，文件格式复杂，传输占带宽；
    - 服务器端和客户端都需要花费大量代码来解析XML，导致服务器端和客户端代码变得异常复杂且不易维护；
    - 客户端不同浏览器之间解析XML的方式不一致，需要重复编写很多代码；
    - 服务器端和客户端解析XML花费较多的资源和时间。

## JSON定义
JSON(JavaScript Object Notation)一种轻量级的数据交换格式，具有良好的可读和便于快速编写的特性。可在不同平台之间进行数据交换。JSON采用兼容性很高的、完全独立于语言文本格式，同时也具备类似于C语言的习惯(包括C, C++, C#, Java, JavaScript, Perl, Python等)体系的行为。这些特性使JSON成为理想的数据交换语言。
JSON基于JavaScript Programming Language , Standard ECMA-262 3rd Edition - December 1999 的一个子集。

## JSON的优缺点
1. JSON的优点：
   - .数据格式比较简单，易于读写，格式都是压缩的，占用带宽小；
   - .易于解析，客户端JavaScript可以简单的通过eval()进行JSON数据的读取；
   - .支持多种语言，包括ActionScript, C, C#, ColdFusion, Java, JavaScript, Perl, PHP, Python, Ruby等服务器端语言，便于服务器端的解析；
   - .在PHP世界，已经有PHP-JSON和JSON-PHP出现了，偏于PHP序列化后的程序直接调用，PHP服务器端的对象、数组等能直接生成JSON格式，便于客户端的访问提取；
   - .因为JSON格式能直接为服务器端代码使用，大大简化了服务器端和客户端的代码开发量，且完成任务不变，并且易于维护。

2. JSON的缺点
   - .没有XML格式这么推广的深入人心和喜用广泛，没有XML那么通用性；
   - .JSON格式目前在Web Service中推广还属于初级阶段。

## XML和JSON的优缺点对比
- JSON和XML的数据可读性基本相同，JSON和XML的可读性可谓不相上下，一边是建议的语法，一边是规范的标签形式，XML可读性较好些。
- XML天生有很好的扩展性，JSON当然也有，没有什么是XML能扩展，JSON不能的。
- XML有丰富的编码工具，比如Dom4j、JDom等，JSON也有json.org提供的工具，但是JSON的编码明显比XML容易许多，即使不借助工具也能写出JSON的代码，可是要写好XML就不太容易了。
- XML的解析得考虑子节点父节点，让人头昏眼花，而JSON的解析难度几乎为0。
- JSON相对于XML来讲，数据的体积小，传递的速度更快些。
- JSON与JavaScript的交互更加方便，更容易解析处理，更好的数据交互。
- JSON的速度要远远快于XML。

---

### 相比JSON和XML的文本格式，二进制数据格式有下面这些优点:

- 编码之后拥有更小的数据体积（因为采用域标签来代替完整的域的值）
- 数据声明本身就可以当做是接口文档使用，而且保证是线上运行的最新版本。
- 对于静态语言而言，在编译时做类型检查的特性可以规避很多问题。


## Thrift与Protocol Buffers
在大量调用或者需要传输大量数据的时候，数据编码之后的体积大小就是一个尤为关键的因素。Apache Thrift和Protocol Buffers(protobuf)就是业界最为知名的两种二进制编码格式。其中前者由Facebook发起并贡献给了Apache作为开源项目，后者则有Google发起并开源。两者格式有很多相似之处，一般都是作为接口定义语言(IDL)配合RPC传输协议使用。
```txt
# 一个thrift例子
struct Person {
  1: required string userName,
  2: optional i64 favoriteNumber,
  3: optional list<string> interests
}

# 一个protobuf例子
message Person {
  required string user_name = 1;
  optional int64 favorite_number = 2;
  repeated string interests = 3;
}
```
相比之前提到的JSON格式，这两者最大的优势在于编码时避免使用完整键的值，而是使用域标签作为键(通常是1,2,3这样的整形数字)。在Thrift和protobuf里，域标签就代表一个字段，而不用完整的键来代表一个字段。
需要提到的一点是，在字段标示属性由一个optional或者required字段。这个属性表明该字段是否是必填，required的校验是在运行时做的，编码时这两种属性并没有实质差异。

来看一下，thrift和protobuf是怎么处理向前兼容和向后兼容的。就像上面说的，字段是和域标签一对一绑定的。也就是说字段名可以变换，而对于同一字段的域标签则要保持不变。当需要添加新字段时，将新的域标签绑定到新字段上即可。对于旧代码读取新数据的情况，未被代码端标示的字段将被自动抛弃而不影响其他字段的读取，由此可见，向前兼容可以被轻松实现。
由于域标签在struct层级保持唯一，新代码可以轻松按照域标签读取旧数据。需要注意的一点是，新添加的字段不能被标记成required，否则在新代码读取旧数据时发生字段缺少的问题。同样的，删除字段时也应该只删除optional字段。域标签和字段的绑定关系应该保持不变，不能用新的字段绑定旧的域标签。
更换字段的数据类型不会发生报错，但是可以会出现精度损失或者溢出的情况(旧代码端的i32读取新数据模式的i64可能会出现溢出情况，旧代码的i32读取新数据模式的float则会出现精度损失)。

## Avro
Apache Avro是另一种二进制数据格式。它是Hadoop项目的一个子项，致力于解决HDFS内的数据传输。
Avro允许读写两种数据模式的存在。读写两种模式之间的字段按照字段名进行匹配。

相比JSON和XML，二进制数据格式有下面这些优点:

编码之后拥有更小的数据体积（因为采用域标签来代替完整的域的值）
数据声明本身就可以当做是接口文档使用，而且保证是线上运行的最新版本。
对于静态语言而言，在编译时做类型检查的特性可以规避很多问题。

## FlatBuffers
FlatBuffers 的使用和 Protocol buffers 基本类似。只不过功能比 Protocol buffers 多了一个解析 JSON 的功能。
- 编写 schema 文件，描述数据结构和接口定义。
- 用 flatc 编译，生成相应语言的代码文件。
- 解析 JSON 数据，把数据存储成对应的 schema，并存入 FlatBuffers 二进制文件中。
- 使用 FlatBuffers 支持的语言（如C ++，Java等）生成的文件进行开发。

## MessagePack
MessagePack  是一个高效的二进制序列化格式。它让你像JSON一样可以在各种语言之间交换数据。但是它比JSON更快、更小。小的整数会被编码成一个字节，短的字符串仅仅只需要比它的长度多一字节的大小。

## Cap'n Proto
Cap'n Proto的编码是方案是独立于任何平台的，但在现在的CPU上面（小端序）会有更高的性能。数据的组织类似compiler组织struct：固定宽度，固定偏移，以及合适的内存对齐，对于可变的数组使用pointer嵌入，而pointer也是使用的偏移存放而不是绝对地址。整数使用的是小端序，因为多数现代CPU都是小端序的。

跟Protobuf一样，Cap'n Proto也需要定义描述文件，然后通过capnp的编译器编译成特定语言的对象使用。一个描述文件的简单例子:

```txt
@0xdbb9ad1f14bf0b36;  # unique file ID, generated by `capnp id`

struct Person {
  name @0 :Text;
  birthdate @3 :Date;

  email @1 :Text;
  phones @2 :List(PhoneNumber);

  struct PhoneNumber {
    number @0 :Text;
    type @1 :Type;

    enum Type {
      mobile @0;
      home @1;
      work @2;
    }
  }
}

struct Date {
  year @0 :Int16;
  month @1 :UInt8;
  day @2 :UInt8;
}
```
几个需要关注的地方:
- 类型是定义在名字后面的，通常来说，对于一个变量来说，我们可能最关注的是它的名字，一个好的命名，就很容易让大家知道是干啥的。譬如上面的name一看就知道是表示的用户的名字。这点跟c语言是反的，它是先类型，在变量名，不过很多后续的语言，譬如go，rust等都是先名字，再类型了。
- @N用来给struct里面的field进行编号，编号从0开始，而且必须是连续的（这点跟Protobuf不一样）。上面birthdate虽然看起来在email和phones的前面，但是它的编号较大，实际编码的时候会放到后面。

