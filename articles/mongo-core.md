
# MongoDB 知识点
- [存储引擎](#存储引擎)
- [索引](#索引)
- [调优](#调优)
- [锁](#锁)
- [事务]
- [日志系统]
- [分片集群]

## 存储引擎
从MongoDB 3.2 版本开始，MongoDB 支持多数据存储引擎，MongoDB支持的存储引擎有：WiredTiger，MMAPv1和In-Memory。

MongoDB 3.2 开始默认的存储引擎是WiredTiger，3.3版本之前的默认存储引擎是MMAPv1，MongoDB4.x版本不再支持MMAPv1存储引擎。

MongoDB不仅能将数据持久化存储到硬盘文件中，而且还能将数据只保存到内存中；In-Memory存储引擎用于将数据只存储在内存中，只将少量的元数据和诊断日志（Diagnostic）存储到硬盘文件中，由于不需要Disk的IO操作，就能获取索取的数据，In-Memory存储引擎大幅度降低了数据查询的延迟（Latency）

### WiredTiger
mongodb3.2开始mongodb默认支持WiredTiger存储引擎

WiredTiger存储引擎的主要优势：

#### 最大化可用缓存： 
WiredTiger最大限度地利用可用内存作为缓存来减少I / O瓶颈。

使用了两个缓存：WiredTiger缓存和文件系统缓存。
- WiredTiger缓存存储未压缩的数据并提供类似内存的性能。
- 操作系统的文件系统缓存存储压缩数据。
- 当在WiredTiger缓存中找不到数据时，WiredTiger将在文件系统缓存中查找数据。

WiredTiger缓存在保存尽可能多的工作集时表现最佳。但是，为需要它的其他进程（如操作系统，包括文件系统缓存）保留内存也很重要。这也包括MongoDB本身，整体上消耗的内存比WiredTiger主动使用的内存多。

MongoDB默认为WiredTiger缓存大小约为RAM的60％。离开文件系统缓存的最小量是可用内存的20％。任何较低的操作系统都可能受限于资源。


#### 高吞吐量： 
WiredTiger使用“写入时复制” - 当文档更新时，WiredTiger将制作文档的新副本并确定最新版本以返回给读者。此方法允许多个客户端同时修改集合中的不同文档，从而实现更高的并发性和吞吐量。当应用程序使用具有多个内核的主机（越多越好）并且多个线程正在写入不同的文档时，实现最佳写入性能。

#### 减少存储空间并改善磁盘IOP： 
WiredTiger使用压缩算法来减少磁盘上存储的数据量。不仅存储减少了，而且随着从磁盘读取或写入更少的位，IOP性能也会提高。某些类型的文件比其他文件压缩得更好。文本文件是高度可压缩的，而二进制数据可能不是可压缩的，因为它可能已经被编码和压缩。使用压缩时，WiredTiger会产生额外的CPU周期，但用户可以配置压缩方案以优化CPU开销与压缩比。Snappy是默认的压缩引擎，在高压缩率和低CPU开销之间提供了良好的平衡。Zlib将实现更高的压缩比，但会产生额外的CPU周期。

#### 压缩（索引和journals日志）：
索引可以在内存和磁盘上压缩。WiredTiger利用前缀压缩来压缩索引，节省RAM使用以及释放存储IOP。默认情况下，使用Snappy压缩压缩journals日志。

#### 多核可扩展性：
随着CPU制造商缩小到更小的平版印刷，功耗变得越来越成问题，处理器趋势已转向多核架构，以维持摩尔定律的节奏。WiredTiger在设计时考虑了现代的多核架构，并提供跨多核系统的可扩展性。危险指针，无锁算法和快速锁存等编程技术可最大限度地减少线程之间的争用。线程可以执行操作而不会相互阻塞 - 从而减少线程争用，更好的并发性和更高的吞吐量。

WiredTiger允许用户为其读取指定隔离级别。读取操作可以返回大部分副本集已接受或提交到磁盘的数据视图。这样可以保证应用程序只读取在发生故障时仍然存在的数据，并且在将新的副本集成员提升为主要成员时不会回滚。


#### 内存使用
在上面提到过：【最大化可用缓存： WiredTiger最大限度地利用可用内存作为缓存来减少I / O瓶颈。使用了两个缓存：WiredTiger缓存和文件系统缓存。WiredTiger缓存存储未压缩的数据并提供类似内存的性能。操作系统的文件系统缓存存储压缩数据。当在WiredTiger缓存中找不到数据时，WiredTiger将在文件系统缓存中查找数据。】

mongodb从3.4版本开始默认使用内存为下面两个中的最大一个：
- 50% of (RAM - 1 GB)
- 256MB
- 
默认情况下，WiredTiger对所有集合使用Snappy块压缩，对所有索引使用前缀压缩。压缩默认值可在全局级别配置，也可以在集合和索引创建时单独指定压缩级别。



#### 文档级并发
WiredTiger使用文档级并发控制进行写操作。因此，多个客户端可以同时修改集合的不同文档。

对于大多数读写操作，WiredTiger使用乐观并发控制。WiredTiger仅在全局，数据库和集合级别使用意图锁。当存储引擎检测到两个操作之间的冲突时，会发生写入冲突，导致MongoDB透明地重试该操作。

一些全局操作（通常是涉及多个数据库的短期操作）仍然需要全局“实例范围”锁定。其他一些操作（例如删除集合）仍需要独占数据库锁。

#### checkpoint
在Checkpoint操作开始时，WiredTiger提供指定时间点（point-in-time）的数据库快照（Snapshot），该Snapshot呈现的是内存中数据的一致性视图。当向Disk写入数据时，WiredTiger将Snapshot中的所有数据以一致性方式写入到数据文件（Disk Files）中。一旦Checkpoint创建成功，WiredTiger保证数据文件和内存数据是一致性的，因此，Checkpoint担当的是还原点（Recovery Point），Checkpoint操作能够缩短MongoDB从Journal日志文件还原数据的时间。

当WiredTiger创建Checkpoint时，MongoDB将数据刷新到数据文件（Disk Files）中，在默认情况下，WiredTiger创建Checkpoint的时间间隔是60s，或产生2GB的Journal文件。在WiredTiger创建新的Checkpoint期间，上一个Checkpoint仍然是有效的，这意味着，即使MongoDB在创建新的Checkpoint期间遭遇到错误而异常终止运行，只要重启，MongoDB就能从上一个有效的Checkpoint开始还原数据。

当MongoDB以原子方式更新WiredTiger的元数据表，使其引用新的Checkpoint时，表明新的Checkpoint创建成功，MongoDB将老的Checkpoint占用的Disk空间释放。使用WiredTiger 存储引擎，如果没有记录数据更新的日志，MongoDB只能还原到上一个Checkpoint；如果要还原在上一个Checkpoint之后执行的修改操作，必须使用Jounal日志文件。

#### journal日志
WiredTiger使用预写日志的机制，在数据更新时，先将数据更新写入到日志文件，然后在创建Checkpoint操作开始时，将日志文件中记录的操作，刷新到数据文件，就是说，通过预写日志和Checkpoint，将数据更新持久化到数据文件中，实现数据的一致性。WiredTiger 日志文件会持久化记录从上一次Checkpoint操作之后发生的所有数据更新，在MongoDB系统崩溃时，通过日志文件能够还原从上次Checkpoint操作之后发生的数据更新。

#### disk回收：
当从MongoDB中删除文档（Documents）或集合（Collections）后，MongoDB不会将Disk空间释放给OS，MongoDB在数据文件（Data Files）中维护Empty Records的列表。当重新插入数据后，MongoDB从Empty Records列表中分配存储空间给新的Document，因此，不需要重新开辟空间。为了更新有效的重用Disk空间，必须重新整理数据碎片。

#### 压缩
使用WiredTiger，MongoDB支持对所有集合和索引进行压缩。压缩可以以额外的CPU为代价最大限度地减少磁盘的使用。

默认情况下WiredTiger存储引擎使用snappy方式压缩所有集合，前缀压缩方式压缩索引。

对于集合的压缩还可以使用zlib方式压缩。



### MongoDB内存存储引擎  In-Memory 

从MongoDB Enterprise 3.2.6开始，In-Memory内存存储引擎是64位版本中通用可用性（GA）的一部分。除某些元数据和诊断数据外，In-Memory内存存储引擎不维护任何磁盘上的数据，包括配置数据、索引、用户凭据等。

通过避免磁盘I / O，内存中存储引擎使数据库操作的延迟更可预测。

#### 并发
in-memory内存存储引擎将文档级并发控制用于写入操作。因此，多个客户端可以同时修改集合的不同文档。

#### 内存使用
内存存储引擎要求其所有数据（包括索引，oplog（如果mongod实例是副本集的一部分）等）必须适合指定的–inMemorySizeGB命令行选项或 YAML配置文件中的storage.inMemory.engineConfig.inMemorySizeGB设置。

默认情况下，in-memory 内存存储引擎使用50％的（物理RAM减去1GB）。

#### 持久性
内存中存储引擎是非持久性的，不会将数据写入持久性存储。非持久数据包括应用程序数据和系统数据，例如用户，权限，索引，副本集配置，分片群集配置等。

因此，日志或等待数据变得持久的概念不适用于内存中的存储引擎。


#### 部署架构
除了独立运行外，使用in-memory内存存储引擎的mongod实例还可以作为副本集的一部分或分片群集的一部分运行。

#### 复制集
可以部署将in-memory内存存储引擎用作副本集一部分的mongod实例。例如，作为三副本集的一部分，您可能需要修改配置：

两个mongod实例与内存存储引擎一起运行。
一个使用WiredTiger存储引擎运行的mongod实例。将WiredTiger成员配置为隐藏成员（即hidden：true和优先级：0）。
使用此部署模型，只有与in-memory内存存储引擎一起运行的mongod实例才能成为主要实例。客户端仅连接到内存存储引擎mongod实例。即使两个运行内存存储引擎的mongod实例都崩溃并重新启动，它们也可以从运行WiredTiger的成员进行同步。与WiredTiger一起运行的隐藏mongod实例会将数据持久保存到磁盘，包括用户数据，索引和复制配置信息。

#### 分片集群
可以将使用内存存储引擎的mongod实例部署为分片群集的一部分。例如，在分片群集中，您可以拥有一个由以下副本集组成的分片：

两个mongod实例与内存存储引擎一起运行
一个WiredTiger存储引擎运行的mongod实例。将WiredTiger成员配置为隐藏成员（即hidden：true和优先级：0）。
在此分片节点上，添加标记inmem。例如，如果此分片的名称为shardC，请连接到mongos并运行sh.addShardTag（）命令，添加标签。


## 索引
MongoDB中的索引和其他数据库索引类似，也是使用B-Tree结构。MongoDB的索引是在collection级别上的，并且支持在任何列或者集合内的文档的子列中创建索引。

Mongodb的索引默认使用的是B-tree这一特殊的数据结

B-tree索引具有分层树结构，树顶部是header block，包含指向任何给定范围的键值的适当branch block的指针。而branch block通常会指向适当的leaf block以获得更具体的范围，或者对于更大的索引会继续指向branch block然后到leaf block，因为leaf block上才包含一个键值列表和指向磁盘上文档位置的指针。

而B-tree索引具有以下优点：

1. 由于每个叶子节点处于相同的深度，所以性能是非常可预测的。 从理论上讲，集合中的任何文档都不会超过三或四次I/O。

2. B树为大型集合提供了良好的性能，因为深度最多为四个（一个头部块，两个分支块级别和一个叶子块级别）。 一般来说，没有任何文件需要四个以上的I/O来定位。 实际上，因为头部块几乎总是已经加载到内存中，而分支块通常加载到内存中，所以实际的物理磁盘读取次数通常只有一次或两次。

3. 因为与前一个和后一个叶子块的链接，所以B-tree索引支持范围查询以及精确的查找是可行的。


### 索引类型
mongoDB支持_id索引 、单键索引、多键索引（当一个被索引的值是数组时，MongoDB会索引这个数组中的每一个元素。更多信息在 multikey模块有详细说明）、复合索引（多个字段，可以分别指定升降序）、时期过期索引（过一段时间索引失效）、全文索引、地理位置索引、稀疏索引（允许索引的字段为空值，建立时跳过）、部分索引（对满足条件的字段建立索引，比如给月工资1W以上的小伙伴建立索引）

#### 默认_id 索引
MongoDB 在创建集合期间在_id字段上创建了唯一索引。该索引可防止客户端插入两个_id字段值相同的文档。_id字段的索引不能删除。

#### 单字段索引 （Single Field Index）
除MongoDB定义的_id索引外，MongoDB还支持在文档的单个字段上创建用户定义的升序/降序索引。

对于单字段索引和排序操作，索引键的排序顺序（即升序或降序）无关紧要，因为MongoDB可以在任一方向上遍历索引。

#### 复合索引
MongoDB支持用户在多个字段上定义索引，即 复合索引。

复合索引中字段的顺序很重要。例如，如果复合索引为{ userid: 1, score: -1 }，则索引首先以userid字段进行排序，然后在每个userid 值以score字段进行排序。

对于复合索引和排序操作，索引键的排序顺序（即升序或降序）可以确定索引是否可以支持排序操作。有关索引顺序对复合索引中结果的影响的详细信息，请参阅 排序顺序。

#### 多键索引
MongoDB使用多键索引来索引存储在数组中的内容。如果索引字段包含数组值，MongoDB会为数组的每个元素创建单独的索引条目。这些多键索引允许查询通过匹配数组中的元素来获取包含数组的文档。如果索引字段包含数组值，MongoDB会自动决定是否需要创建多键索引; 不需要显式指定多键类型。

多键索引和多键索引边界 获取有关多键索引的详细信息。

#### 地理空间索引

为了支持对地理空间坐标数据的高效查询，MongoDB提供了两个特殊索引：返回结果时使用平面几何的2d索引和使用球面几何的2dphere索引。

有关地理空间索引的更多介绍，请参阅2d Index Internals。

#### 文本索引

MongoDB提供了一种text索引类型，支持在集合中搜索字符串内容。这些文本索引不存储特定于语言的停用词（例如“the”，“a”，“or”），并且集合中的词干均仅存储词根。
有关文本索引和搜索的详细信息，请参阅文本索引。

#### 哈希索引

为了支持基于哈希的分片，MongoDB提供了哈希索引类型，索引字段值的哈希值。这些索引在其范围内具有更随机的值分布，但仅 支持等值匹配且不支持范围查询。

### 索引属性
1. 唯一索引:索引的唯一属性会导致MongoDB拒绝索引字段的重复值。除了唯一约束之外，唯一索引在功能上可与其他MongoDB索引互换。
2. 部分索引: 
    - 3.2版本的新功能。
    - 部分索引仅索引符合特定的过滤表达式的集合中的文档。通过索引集合中的文档子集，部分索引具有较低的存储要求，减少索引创建和维护的性能成本
    - 部分索引是稀疏索引功能的超集，应该优先于稀疏索引。
3. 稀疏索引
   - 索引的稀疏属性可确保索引仅包含具有索引字段的文档的条目。索引会跳过没有索引字段的文档。
   - 将稀疏索引与唯一索引组合，以拒绝具有字段重复值的文档，但忽略没有索引键的文档。
4. TTL索引:TTL索引是MongoDB在指定时间后自动从集合中删除文档的特殊索引。这是某些类型的信息理想选择，例如机器生成的事件数据，日志和会话信息，这些信息只需要在数据库中保存有限的时间。

#### 覆盖查询
当查询标准和查询投影仅包含索引字段，MongoDB的可以直接从索引返回结果，无需扫描的任何文档或文档加载到内存。这些覆盖的查询可以非常有效。

#### 交叉索引
2.6版中的新功能。

MongoDB可以使用交叉索引来完成查询。对于指定复合查询条件的查询，如果一个索引可以满足查询条件的一部分，而另一个索引可以满足查询条件的另一部分，则MongoDB可以使用两个索引的交集来完成查询。使用复合索引还是使用索引交集更有效取决于具体的查询和系统。


### 调优
#### db profiling

MongoDB支持对DB的请求进行profiling，目前支持3种级别的profiling。
- 0： 不开启profiling
- 1： 将处理时间超过某个阈值(默认100ms)的请求都记录到DB下的system.profile集合 （类似于mysql、redis的slowlog）
- 2： 将所有的请求都记录到DB下的system.profile集合（生产环境慎用）

常，生产环境建议使用1级别的profiling，并根据自身需求配置合理的阈值，用于监测慢请求的情况，并及时的做索引优化。

如果能在集合创建的时候就能『根据业务查询需求决定应该创建哪些索引』，当然是最佳的选择；但由于业务需求多变，要根据实际情况不断的进行优化。索引并不是越多越好，集合的索引太多，会影响写入、更新的性能，每次写入都需要更新所有索引的数据；所以你system.profile里的慢请求可能是索引建立的不够导致，也可能是索引过多导致。

#### 通过explain结果来分析性能
我们往往会通过打点数据来分析业务的性能瓶颈，这时，我们会发现很多瓶颈都是出现在数据库相关的操作上，这时由于数据库的查询和存取都涉及大量的IO操作，而且有时由于使用不当，会导致IO操作的大幅度增长，从而导致了产生性能问题。而MongoDB提供了一个explain工具来用于分析数据库的操作。

### 锁

MongoDB 使用的是“readers-writer”锁， 可以支持并发但有很大的局限性当一个读锁存在,许多读操作可以使用这把锁，然而, 当一个写锁的存在，一个单一的写操作会”exclusively“持有该锁，同一时间其它写操作不能使用共享这个锁；

举个例子，假设一个集合里有10个文档，多个update操作不能并发在这个集合上，即使是更新不同的文档。

#### 锁的粒度

在 2.2 版本以前，一个mongodb实例一个写锁，多个读锁。也就是说mongod 只有全局锁(锁定一个server)；

在2.2-3.0的版本，一个数据库一个写锁，多个读锁。例如如果一个 mongod 实例上有 5 个库，如果只对一个库中的一个集合执行写操作，那么在写操作过程中，这个库被锁；而其它 4 个库不影响。相比 RDBMS 来说，这个粒度已经算很大了！

在3.0之后的版本，WiredTiger提供了文档（不是集合）级别的锁。

更新：MongoDB 3.4版本，写操作的锁定粒度在表中数据记录(document)级别，即使操作对象可能是多条数据，每条数据在被写入时都会被锁定，防止其他进程写入；但是写操作是非事务性的，即写入多条数据，即使当前写入操作还没有完成，前面已经写入的数据也可以被其他进程修改。除非指定了$isolated，一次写入操作影响的数据无法在本次操作结束之前被其他进程修改。

$isolated也是非事务性的，即如果写入过程出错，已经完成的写入操作不会被rollback；另外，
$isolated需要额外的锁，无法用于sharded方式部署的集群。

#### MongoDB高吞吐的原因：

MongoDB 没有完整事务支持，操作原子性只到单个 document 级别，所以通常操作粒度比较小；
MongoDB 锁实际占用时间是内存数据计算和变更时间，通常很快；
MongoDB 锁有一种临时放弃机制，当出现需要等待慢速 IO 读写数据时，可以先临时放弃，等 IO 完成之后再重新获取锁。

#### 哪些操作会对数据库产生锁？

下表列出了常见数据库操作产生的锁。

操作	锁定类型

查询	读锁

通过cursor读取数据	读锁

插入数据	写锁

删除数据	写锁

修改数据	写锁

Map-reduce	读写锁均有，除非指定为non-atomic，部分mapreduce任务可以同时执行(猜测是生成的中间表不冲突的情况下)

添加index	通过前台API添加index，锁定数据库一段时间

db.eval()	写锁，同时阻塞其他运行在MongoDB上的JavaScript进程

eval	写锁，如果设定锁定选项是nolock，则不会有些锁，而且eval无法向数据库写入数据

aggregate()	读锁


#### 如何查看锁的状态
```sql
db.serverStatus()
db.currentOp()
mongotop # 类似top命令，每秒刷新
mongostat
the MongoDB Monitoring Service (MMS)
```

#### 哪些数据库管理操作会锁数据库？

某些数据库管理操作会 exclusively 锁住数据库，以下命令需要申请 exclusively 锁，并锁定一段时间
```sql
db.collection.ensureIndex(),
reIndex,
compact,
db.repairDatabase(),
db.createCollection(), when creating a very large (i.e. many gigabytes) capped collection,
db.collection.validate(),
db.copyDatabase() # 可能会锁定所有数据库(database)
```

以下命令需要申请 exclusively 锁，但锁定很短时间。
```sql
db.collection.dropIndex(),
db.collection.getLastError(),
db.isMaster(),
rs.status() (i.e. replSetGetStatus,)
db.serverStatus(),
db.auth(), and
db.addUser().
```

备注：可见，一些查看命令也会锁库，在比较繁忙的生产库中，也会有影响的。

#### MongoDB内部可能锁住所有库的操作

以下数据库内部操作会锁定多个库。

日志管理 MongoDB的内部操作，每个一段时间就锁定所有数据库，所有的数据库共享一份日志
用户认证 锁定admin数据库和用户正在申请访问的数据库
所有写入备份数据库(replica)的操作都会锁定写入目标数据库和本地数据库，本地数据库的写入锁允许写入主节点的oplog