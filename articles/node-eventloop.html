<!doctype html>
<html>
    <head>
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"/>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
        <meta name="description" content="Content of description meta tag"/>
        <meta name="keywords" content="keyword1,keyword2,keyword3"/>
        <meta name="author" content="Content of author meta tag"/>
        <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
        <title>chuhongliang.github.io - Node 中的 Event Loop
</title>
        <link rel="stylesheet" href="/assets/vendor/normalize.css"/>
        <link rel="stylesheet" href="/assets/vendor/prettify-night.css"/>
        <link rel="stylesheet" href="/assets/themes/default/main.css"/>
        <link rel="shortcut icon" href="/fav.ico"/>
        <script type="text/javascript" src="/assets/vendor/prettify.js"></script>
        
    </head>
    <body onload="prettyPrint()">
    <div id="header">
        <div id="header-inner">
            <div id="title"><a href="/">chuhongliang.github.io</a></div>
            <div id="subtitle">learn coding, keep coding</div>
        </div>
    </div>

<div id="main">
    <div id="main-inner">
        <div id="topnav">
            <ul>
                <li><a href="/">首页</a></li>
                <li class="sep"> | </li>
                <li><a href="/tag.html">标签</a></li>
                
<li class="sep"> | </li>
<li><a href="/pages/about-me.html" target="_self">关于我</a></li>

<li class="sep"> | </li>
<li><a href="https://github.com/chuhongliang" target="_blank">github</a></li>


            </ul>
            <div style="clear:both;"></div>
        </div>
        <div id="article-title">
            <a href="/articles/node-eventloop.html">Node 中的 Event Loop</a>
        </div>
        <div id="article-meta">
            作者 chuhongliang | 发布于 2020-02-03
        </div>
        <div id="article-tags">
        
        <a class="tag" href="/tag.html#Node">Node</a>
        
        </div>
        <div id="article-content">
            <ul>
<li>Node.js采用V8作为js的解析引擎，而I/O处理方面使用了自己设计的libuv，libuv是一个基于事件驱动的跨平台抽象层，封装了不同操作系统一些底层特性，对外提供统一的API，事件循环机制也是它里面的实现。</li>
<li>在Node.js启动的时候，它会初始化EventLoop，处理程序代码，可能是调用异步API、定时器或者调用process.nextTick()，然后开始事件轮询。</li>
</ul>
<p>根据Node.js官方介绍，每次事件循环都包含了6个阶段，对应到 libuv 源码中的实现，如下图所示</p>
<pre class="prettyprint linenums lang-txt">   ┌───────────────────────┐
┌─&gt;│        timers         │
│  └──────────┬────────────┘
│  ┌──────────┴────────────┐
│  │     I/O callbacks     │
│  └──────────┬────────────┘
│  ┌──────────┴────────────┐
│  │     idle, prepare     │
│  └──────────┬────────────┘      ┌───────────────┐
│  ┌──────────┴────────────┐      │   incoming:   │
│  │         poll          │&lt;─────┤  connections, │
│  └──────────┬────────────┘      │   data, etc.  │
│  ┌──────────┴────────────┐      └───────────────┘
│  │        check          │
│  └──────────┬────────────┘
│  ┌──────────┴────────────┐
└──┤    close callbacks    │
   └───────────────────────┘
</pre>
<ul>
<li><code>timers</code> 阶段: 这个阶段执行setTimeout(callback) and setInterval(callback)预定的callback;</li>
<li><code>I/O callbacks</code> 阶段: 执行除了 close事件的callbacks、被timers(定时器，setTimeout、- setInterval等)设定的callbacks、setImmediate()设定的callbacks之外的callbacks;</li>
<li><code>idle, prepare</code> 阶段: 仅node内部使用;</li>
<li><code>poll</code> 阶段: 获取新的I/O事件, 适当的条件下node将阻塞在这里;</li>
<li><code>check</code> 阶段: 执行setImmediate() 设定的callbacks;</li>
<li><code>close</code> callbacks 阶段: 比如socket.on(‘close’, callback)的callback会在这个阶段执行.</li>
</ul>
<p>每一个阶段都有一个装有callbacks的fifo queue(队列)，当event loop运行到一个指定阶段时，
node将执行该阶段的fifo queue(队列)，当队列callback执行完或者执行callbacks数量超过该阶段的上限时，
event loop会转入下一下阶段.</p>
<p>&nbsp;</p>
<h3 id="-code-timers-code-阶段"><code>timers</code> 阶段</h3>
<ul>
<li>timers 是事件循环的第一个阶段，Node 会去检查有无已过期的timer，如果有则把它的回调压入timer的任务队列中等待执行，事实上，Node 并不能保证timer在预设时间到了就会立即执行，因为Node对timer的过期检查不一定靠谱，它会受机器上其它运行程序影响，或者那个时间点主线程不空闲。</li>
</ul>
<p>比如下面的代码，setTimeout() 和 setImmediate() 的执行顺序是不确定的</p>
<pre class="prettyprint linenums lang-js">setTimeout(() =&gt; {
  console.log(&#39;timeout&#39;)
}, 0)
setImmediate(() =&gt; {
  console.log(&#39;immediate&#39;)
})
</pre>
<p>但是把它们放到一个I/O回调里面，就一定是 setImmediate() 先执行，因为poll阶段后面就是check阶段。</p>
<p>&nbsp;</p>
<h3 id="-code-poll-code-阶段"><code>poll</code> 阶段</h3>
<p>poll 阶段主要有2个功能：</p>
<ul>
<li>处理 poll 队列的事件</li>
<li>当有已超时的 timer，执行它的回调函数</li>
</ul>
<p>event-loop将同步执行poll队列里的回调，直到队列为空或执行的回调达到系统上限（上限具体多少未详），接下来even loop会去检查有无预设的setImmediate()，分两种情况：</p>
<ul>
<li>若有预设的setImmediate(), event loop将结束poll阶段进入check阶段，并执行check阶段的任务队列</li>
<li>若没有预设的setImmediate()，event loop将阻塞在该阶段等待</li>
</ul>
<p>注意一个细节，没有setImmediate()会导致event loop阻塞在poll阶段，这样之前设置的timer岂不是执行不了了？所以咧，在poll阶段event loop会有一个检查机制，检查timer队列是否为空，如果timer队列非空，event loop就开始下一轮事件循环，即重新进入到timer阶段。</p>
<p>&nbsp;</p>
<h3 id="-code-check-code-阶段"><code>check</code> 阶段</h3>
<ul>
<li>setImmediate()的回调会被加入check队列中， 从event loop的阶段图可以知道，check阶段的执行顺序在poll阶段之后。</li>
</ul>
<p>&nbsp;</p>
<h3 id="-code-processnexttick-code-"><code>process.nextTick</code></h3>
<ul>
<li>process.nextTick() 会在各个事件阶段之间执行，一旦执行，要直到nextTick队列被清空，才会进入到下一个事件阶段，所以如果递归调用 process.nextTick()，会导致出现I/O starving（饥饿）的问题，比如下面例子的readFile已经完成，但它的回调一直无法执行：</li>
</ul>
<pre class="prettyprint linenums lang-js">const fs = require(&#39;fs&#39;)
const starttime = Date.now()
let endtime
fs.readFile(&#39;text.txt&#39;, () =&gt; {
  endtime = Date.now()
  console.log(&#39;finish reading time: &#39;, endtime - starttime)
})
let index = 0
function handler () {
  if (index++ &gt;= 1000) return
  console.log(`nextTick ${index}`)
  process.nextTick(handler)
  // console.log(`setImmediate ${index}`)
  // setImmediate(handler)
}
handler()
</pre>
<p>process.nextTick()的运行结果：</p>
<pre class="prettyprint linenums lang-js">nextTick 1
nextTick 2
......
nextTick 999
nextTick 1000
finish reading time: 170
</pre>
<p>替换成setImmediate()，运行结果：</p>
<pre class="prettyprint linenums lang-js">setImmediate 1
setImmediate 2
finish reading time: 80
......
setImmediate 999
setImmediate 1000
</pre>
<p>这是因为嵌套调用的 setImmediate() 回调，被排到了下一次event loop才执行，所以不会出现阻塞。</p>
<hr>
<h3 id="总结">总结</h3>
<ul>
<li>Node.js 的事件循环分为6个阶段</li>
<li>浏览器和Node 环境下，microtask 任务队列的执行时机不同</li>
<li>Node.js中，microtask 在事件循环的各个阶段之间执行</li>
<li>浏览器端，microtask 在事件循环的 macrotask 执行完之后执行</li>
<li>递归的调用process.nextTick()会导致I/O starving，官方推荐使用setImmediate()</li>
</ul>

        </div>
        
    </div>
</div>
        <div id="footer">
            <div id="footer-inner">
                <p id="copyright">Copyright (c) 2019-至今 Copyrighter</p>
            </div>
        </div>
        <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [['$','$'], ['\\(','\\)']],
            processEscapes: true
        }
    });
</script>
<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>

    </body>
</html>

