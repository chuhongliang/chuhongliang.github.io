<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0">
    <channel>
        <title>RSS feed title</title>
        <link>Homepage link</link>
        <description>RSS feed description</description>
        <lastBuildDate>Sun, 26 Apr 2020 21:47:51 +0800</lastBuildDate>
        <language>zh-cn</language>
        
        <item>
            <title>Node.js co 函数</title>
            <link>Homepage link/articles/node-co.html?utm_source=rss&amp;utm_medium=rss&amp;utm_campaign=rss</link>
            <guid>Homepage link/articles/node-co.html</guid>
            <author>chl01003698@126.com chuhongliang</author>
            <pubDate>Tue, 21 Apr 2020 00:00:00 +0800</pubDate>
            <description>&lt;h1 id=&quot;co-函数库的含义和用法&quot;&gt;co 函数库的含义和用法&lt;/h1&gt;
&lt;p&gt;co 函数库是著名程序员 TJ Holowaychuk 于2013年6月发布的一个小工具，用于 Generator 函数的自动执行。&lt;/p&gt;
&lt;p&gt;比如，有一个 Generator 函数，用于依次读取两个文件。&lt;/p&gt;
&lt;pre class=&quot;prettyprint linenums lang-js&quot;&gt;var gen = function* (){
  var f1 = yield readFile(&#39;/etc/fstab&#39;);
  var f2 = yield readFile(&#39;/etc/shells&#39;);
  console.log(f1.toString());
  console.log(f2.toString());
};
&lt;/pre&gt;
&lt;h4 id=&quot;co-函数库可以让你不用编写-generator-函数的执行器。&quot;&gt;co 函数库可以让你不用编写 Generator 函数的执行器。&lt;/h4&gt;
&lt;pre class=&quot;prettyprint linenums lang-js&quot;&gt;var co = require(&#39;co&#39;);
co(gen);
&lt;/pre&gt;
&lt;p&gt;上面代码中，Generator 函数只要传入 co 函数，就会自动执行。&lt;/p&gt;
&lt;p&gt;co 函数返回一个 Promise 对象，因此可以用 then 方法添加回调函数。&lt;/p&gt;
&lt;pre class=&quot;prettyprint linenums lang-js&quot;&gt;co(gen).then(function (){
  console.log(&#39;Generator 函数执行完成&#39;);
})
&lt;/pre&gt;
&lt;p&gt;上面代码中，等到 Generator 函数执行结束，就会输出一行提示。&lt;/p&gt;
&lt;h1 id=&quot;co-函数库的原理&quot;&gt;co 函数库的原理&lt;/h1&gt;
&lt;p&gt;为什么 co 可以自动执行 Generator 函数？&lt;/p&gt;
&lt;p&gt;前面文章说过，Generator 函数就是一个异步操作的容器。它的自动执行需要一种机制，当异步操作有了结果，能够自动交回执行权。&lt;/p&gt;
&lt;p&gt;两种方法可以做到这一点:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;回调函数。将异步操作包装成 Thunk 函数，在回调函数里面交回执行权。&lt;/li&gt;
&lt;li&gt;Promise 对象。将异步操作包装成 Promise 对象，用 then 方法交回执行权。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;co 函数库其实就是将两种自动执行器（Thunk 函数和 Promise 对象），包装成一个库。使用 co 的前提条件是，Generator 函数的 yield 命令后面，只能是 Thunk 函数或 Promise 对象。&lt;/p&gt;
&lt;h1 id=&quot;基于-promise-对象的自动执行&quot;&gt;基于 Promise 对象的自动执行&lt;/h1&gt;
&lt;p&gt;还是沿用上面的例子。首先，把 fs 模块的 readFile 方法包装成一个 Promise 对象。&lt;/p&gt;
&lt;pre class=&quot;prettyprint linenums lang-js&quot;&gt;var fs = require(&#39;fs&#39;);

var readFile = function (fileName){
  return new Promise(function (resolve, reject){
    fs.readFile(fileName, function(error, data){
      if (error) reject(error);
      resolve(data);
    });
  });
};

var gen = function* (){
  var f1 = yield readFile(&#39;/etc/fstab&#39;);
  var f2 = yield readFile(&#39;/etc/shells&#39;);
  console.log(f1.toString());
  console.log(f2.toString());
};
&lt;/pre&gt;
&lt;p&gt;然后，手动执行上面的 Generator 函数:&lt;/p&gt;
&lt;pre class=&quot;prettyprint linenums lang-js&quot;&gt;var g = gen();

g.next().value.then(function(data){
  g.next(data).value.then(function(data){
    g.next(data);
  });
})
&lt;/pre&gt;
&lt;p&gt;手动执行其实就是用 then 方法，层层添加回调函数。理解了这一点，就可以写出一个自动执行器。&lt;/p&gt;
&lt;pre class=&quot;prettyprint linenums lang-js&quot;&gt;function run(gen){
  var g = gen();

  function next(data){
    var result = g.next(data);
    if (result.done) return result.value;
    result.value.then(function(data){
      next(data);
    });
  }

  next();
}

run(gen);
&lt;/pre&gt;
&lt;p&gt;上面代码中，只要 Generator 函数还没执行到最后一步，next 函数就调用自身，以此实现自动执行。&lt;/p&gt;
&lt;h1 id=&quot;co-函数库的源码&quot;&gt;co 函数库的源码&lt;/h1&gt;
&lt;p&gt;co 就是上面那个自动执行器的扩展，它的源码只有几十行，非常简单。&lt;/p&gt;
&lt;p&gt;首先，co 函数接受 Generator 函数作为参数，返回一个 Promise 对象。&lt;/p&gt;
&lt;pre class=&quot;prettyprint linenums lang-js&quot;&gt;function co(gen) {
  var ctx = this;

  return new Promise(function(resolve, reject) {
  });
}
&lt;/pre&gt;
&lt;p&gt;在返回的 Promise 对象里面，co 先检查参数 gen 是否为 Generator 函数。如果是，就执行该函数，得到一个内部指针对象；如果不是就返回，并将 Promise 对象的状态改为 resolved 。&lt;/p&gt;
&lt;pre class=&quot;prettyprint linenums lang-js&quot;&gt;function co(gen) {
  var ctx = this;

  return new Promise(function(resolve, reject) {
    if (typeof gen === &#39;function&#39;) gen = gen.call(ctx);
    if (!gen || typeof gen.next !== &#39;function&#39;) return resolve(gen);
  });
}
&lt;/pre&gt;
&lt;p&gt;接着，co 将 Generator 函数的内部指针对象的 next 方法，包装成 onFulefilled 函数。这主要是为了能够捕捉抛出的错误。&lt;/p&gt;
&lt;pre class=&quot;prettyprint linenums lang-js&quot;&gt;function co(gen) {
  var ctx = this;

  return new Promise(function(resolve, reject) {
    if (typeof gen === &#39;function&#39;) gen = gen.call(ctx);
    if (!gen || typeof gen.next !== &#39;function&#39;) return resolve(gen);

    onFulfilled();
    function onFulfilled(res) {
      var ret;
      try {
        ret = gen.next(res);
      } catch (e) {
        return reject(e);
      }
      next(ret);
    }    
  });
}
&lt;/pre&gt;
&lt;p&gt;最后，就是关键的 next 函数，它会反复调用自身。&lt;/p&gt;
&lt;pre class=&quot;prettyprint linenums lang-js&quot;&gt;function next(ret) {
  if (ret.done) return resolve(ret.value);
  var value = toPromise.call(ctx, ret.value);
  if (value &amp;&amp; isPromise(value)) return value.then(onFulfilled, onRejected);
  return onRejected(new TypeError(&#39;You may only yield a function, promise, generator, array, or object, &#39;
        + &#39;but the following object was passed: &quot;&#39; + String(ret.value) + &#39;&quot;&#39;));
    }
});
&lt;/pre&gt;
&lt;p&gt;上面代码中，next 函数的内部代码，一共只有四行命令。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一行，检查当前是否为 Generator 函数的最后一步，如果是就返回。&lt;/li&gt;
&lt;li&gt;第二行，确保每一步的返回值，是 Promise 对象。&lt;/li&gt;
&lt;li&gt;第三行，使用 then 方法，为返回值加上回调函数，然后通过 onFulfilled 函数再次调用 next 函数。&lt;/li&gt;
&lt;li&gt;第四行，在参数不符合要求的情况下（参数非 Thunk 函数和 Promise 对象），将 Promise 对象的状态改为 rejected，从而终止执行。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;并发的异步操作&quot;&gt;并发的异步操作&lt;/h1&gt;
&lt;p&gt;co 支持并发的异步操作，即允许某些操作同时进行，等到它们全部完成，才进行下一步。&lt;/p&gt;
&lt;p&gt;这时，要把并发的操作都放在数组或对象里面。&lt;/p&gt;
&lt;pre class=&quot;prettyprint linenums lang-js&quot;&gt;// 数组的写法
co(function* () {
  var res = yield [
    Promise.resolve(1),
    Promise.resolve(2)
  ];
  console.log(res); 
}).catch(onerror);

// 对象的写法
co(function* () {
  var res = yield {
    1: Promise.resolve(1),
    2: Promise.resolve(2),
  };
  console.log(res); 
}).catch(onerror);
&lt;/pre&gt;
</description>
        </item>
        
        <item>
            <title>JavaScript Thunk 函数</title>
            <link>Homepage link/articles/javascript-thunk.html?utm_source=rss&amp;utm_medium=rss&amp;utm_campaign=rss</link>
            <guid>Homepage link/articles/javascript-thunk.html</guid>
            <author>chl01003698@126.com chuhongliang</author>
            <pubDate>Mon, 20 Apr 2020 00:00:00 +0800</pubDate>
            <description>&lt;h1 id=&quot;thunk-函数的含义和用法&quot;&gt;Thunk 函数的含义和用法&lt;/h1&gt;
&lt;p&gt;Thunk函数的定义，它是&quot;传名调用&quot;的一种实现策略，用来替换某个表达式。&lt;/p&gt;
&lt;p&gt;JavaScript 语言是传值调用，它的 Thunk 函数含义有所不同。在 JavaScript 语言中，Thunk 函数替换的不是表达式，而是多参数函数，将其替换成单参数的版本，且只接受回调函数作为参数。&lt;/p&gt;
&lt;pre class=&quot;prettyprint linenums lang-js&quot;&gt;// 正常版本的readFile（多参数版本）
fs.readFile(fileName, callback);

// Thunk版本的readFile（单参数版本）
var readFileThunk = Thunk(fileName);
readFileThunk(callback);

var Thunk = function (fileName){
  return function (callback){
    return fs.readFile(fileName, callback); 
  };
};
&lt;/pre&gt;
&lt;p&gt;上面代码中，fs 模块的 readFile 方法是一个多参数函数，两个参数分别为文件名和回调函数。经过转换器处理，它变成了一个单参数函数，只接受回调函数作为参数。这个单参数版本，就叫做 Thunk 函数。&lt;/p&gt;
&lt;p&gt;任何函数，只要参数有回调函数，就能写成 Thunk 函数的形式。下面是一个简单的 Thunk 函数转换器。&lt;/p&gt;
&lt;pre class=&quot;prettyprint linenums lang-js&quot;&gt;var Thunk = function(fn){
  return function (){
    var args = Array.prototype.slice.call(arguments);
    return function (callback){
      args.push(callback);
      return fn.apply(this, args);
    }
  };
};
&lt;/pre&gt;
&lt;p&gt;使用上面的转换器，生成 fs.readFile 的 Thunk 函数。&lt;/p&gt;
&lt;pre class=&quot;prettyprint linenums lang-js&quot;&gt;var readFileThunk = Thunk(fs.readFile);
readFileThunk(fileA)(callback);
&lt;/pre&gt;
&lt;h2 id=&quot;thunkify-模块&quot;&gt;Thunkify 模块&lt;/h2&gt;
&lt;p&gt;生产环境的转换器，建议使用 Thunkify 模块。&lt;/p&gt;
&lt;h4 id=&quot;安装-&quot;&gt;安装:&lt;/h4&gt;
&lt;pre class=&quot;prettyprint linenums lang-js&quot;&gt;npm install thunkify
&lt;/pre&gt;
&lt;p&gt;使用方式如下:&lt;/p&gt;
&lt;pre class=&quot;prettyprint linenums lang-js&quot;&gt;var thunkify = require(&#39;thunkify&#39;);
var fs = require(&#39;fs&#39;);

var read = thunkify(fs.readFile);
read(&#39;package.json&#39;)(function(err, str){
  // ...
});
&lt;/pre&gt;
&lt;p&gt;Thunkify 的源码。&lt;/p&gt;
&lt;pre class=&quot;prettyprint linenums lang-js&quot;&gt;function thunkify(fn){
  return function(){
    var args = new Array(arguments.length);
    var ctx = this;

    for(var i = 0; i &lt; args.length; ++i) {
      args[i] = arguments[i];
    }

    return function(done){
      var called;

      args.push(function(){
        if (called) return;
        called = true;
        done.apply(null, arguments);
      });

      try {
        fn.apply(ctx, args);
      } catch (err) {
        done(err);
      }
    }
  }
};
&lt;/pre&gt;
&lt;p&gt;它的源码主要多了一个检查机制，变量 called 确保回调函数只运行一次。这样的设计与下文的 Generator 函数相关。请看下面的例子。&lt;/p&gt;
&lt;pre class=&quot;prettyprint linenums lang-js&quot;&gt;function f(a, b, callback){
  var sum = a + b;
  callback(sum);
  callback(sum);
}

var ft = thunkify(f);
ft(1, 2)(console.log); 
// 3
&lt;/pre&gt;
&lt;p&gt;上面代码中，由于 thunkify 只允许回调函数执行一次，所以只输出一行结果。&lt;/p&gt;
&lt;h2 id=&quot;generator-函数的流程管理&quot;&gt;Generator 函数的流程管理&lt;/h2&gt;
&lt;p&gt;Thunk 函数可以用于 Generator 函数的自动流程管理。&lt;/p&gt;
&lt;pre class=&quot;prettyprint linenums lang-js&quot;&gt;var fs = require(&#39;fs&#39;);
var thunkify = require(&#39;thunkify&#39;);
var readFile = thunkify(fs.readFile);

var gen = function* (){
  var r1 = yield readFile(&#39;/etc/fstab&#39;);
  console.log(r1.toString());
  var r2 = yield readFile(&#39;/etc/shells&#39;);
  console.log(r2.toString());
};
&lt;/pre&gt;
&lt;p&gt;上面代码中，yield 命令用于将程序的执行权移出 Generator 函数，那么就需要一种方法，将执行权再交还给 Generator 函数。&lt;/p&gt;
&lt;p&gt;这种方法就是 Thunk 函数，因为它可以在回调函数里，将执行权交还给 Generator 函数。为了便于理解，我们先看如何手动执行上面这个 Generator 函数。&lt;/p&gt;
&lt;pre class=&quot;prettyprint linenums lang-js&quot;&gt;var g = gen();

var r1 = g.next();
r1.value(function(err, data){
  if (err) throw err;
  var r2 = g.next(data);
  r2.value(function(err, data){
    if (err) throw err;
    g.next(data);
  });
});
&lt;/pre&gt;
&lt;p&gt;上面代码中，变量 g 是 Generator 函数的内部指针，表示目前执行到哪一步。next 方法负责将指针移动到下一步，并返回该步的信息（value 属性和 done 属性）。&lt;/p&gt;
&lt;p&gt;仔细查看上面的代码，可以发现 Generator 函数的执行过程，其实是将同一个回调函数，反复传入 next 方法的 value 属性。这使得我们可以用递归来自动完成这个过程。&lt;/p&gt;
&lt;h2 id=&quot;thunk-函数的自动流程管理&quot;&gt;Thunk 函数的自动流程管理&lt;/h2&gt;
&lt;pre class=&quot;prettyprint linenums lang-js&quot;&gt;function run(fn) {
  var gen = fn();

  function next(err, data) {
    var result = gen.next(data);
    if (result.done) return;
    result.value(next);
    }

  next();
}

run(gen);
&lt;/pre&gt;
&lt;p&gt;上面代码的 run 函数，就是一个 Generator 函数的自动执行器。内部的 next 函数就是 Thunk 的回调函数。 next 函数先将指针移到 Generator 函数的下一步（gen.next 方法），然后判断 Generator 函数是否结束（result.done 属性），如果没结束，就将 next 函数再传入 Thunk 函数（result.value 属性），否则就直接退出。&lt;/p&gt;
&lt;p&gt;有了这个执行器，执行 Generator 函数方便多了。不管有多少个异步操作，直接传入 run 函数即可。当然，前提是每一个异步操作，都要是 Thunk 函数，也就是说，跟在 yield 命令后面的必须是 Thunk 函数。&lt;/p&gt;
&lt;pre class=&quot;prettyprint linenums lang-js&quot;&gt;var gen = function* (){
  var f1 = yield readFile(&#39;fileA&#39;);
  var f2 = yield readFile(&#39;fileB&#39;);
  // ...
  var fn = yield readFile(&#39;fileN&#39;);
};

run(gen);
&lt;/pre&gt;
&lt;p&gt;上面代码中，函数 gen 封装了 n 个异步的读取文件操作，只要执行 run 函数，这些操作就会自动完成。这样一来，异步操作不仅可以写得像同步操作，而且一行代码就可以执行。&lt;/p&gt;
&lt;p&gt;Thunk 函数并不是 Generator 函数自动执行的唯一方案。因为自动执行的关键是，必须有一种机制，自动控制 Generator 函数的流程，接收和交还程序的执行权。回调函数可以做到这一点，Promise 对象也可以做到这一点。&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>JavaScript Generator函数</title>
            <link>Homepage link/articles/javascript-generator.html?utm_source=rss&amp;utm_medium=rss&amp;utm_campaign=rss</link>
            <guid>Homepage link/articles/javascript-generator.html</guid>
            <author>chl01003698@126.com chuhongliang</author>
            <pubDate>Mon, 20 Apr 2020 00:00:00 +0800</pubDate>
            <description>&lt;h1 id=&quot;generator-函数的含义与用法&quot;&gt;Generator 函数的含义与用法&lt;/h1&gt;
&lt;p&gt;Generator 函数是协程在 ES6 的实现，最大特点就是可以交出函数的执行权（即暂停执行）。&lt;/p&gt;
&lt;p&gt;Generator 对象是由一个 generator function 返回的,并且它符合可迭代协议和迭代器协议。&lt;/p&gt;
&lt;h2 id=&quot;语法-&quot;&gt;语法:&lt;/h2&gt;
&lt;pre class=&quot;prettyprint linenums lang-js&quot;&gt;function* gen() { 
  yield 1;
  yield 2;
  yield 3;
}
let g = gen(); 
// &quot;Generator { }&quot;
&lt;/pre&gt;
&lt;p&gt;不同于普通函数，Generator 函数是可以暂停执行的，所以函数名之前要加星号，以示区别。&lt;/p&gt;
&lt;p&gt;整个 Generator 函数就是一个封装的异步任务，或者说是异步任务的容器。异步操作需要暂停的地方，都用 yield 语句注明。&lt;/p&gt;
&lt;h2 id=&quot;方法-&quot;&gt;方法:&lt;/h2&gt;
&lt;pre class=&quot;prettyprint linenums lang-js&quot;&gt;Generator.prototype.next()   //返回一个由 yield表达式生成的值。
Generator.prototype.return() //返回给定的值并结束生成器。
Generator.prototype.throw()  //向生成器抛出一个错误。
&lt;/pre&gt;
&lt;h2 id=&quot;generator-函数的执行方法&quot;&gt;Generator 函数的执行方法&lt;/h2&gt;
&lt;pre class=&quot;prettyprint linenums lang-js&quot;&gt;function* gen(x){
  var y = yield x + 2;
  return y;
}

var g = gen(1);
g.next() // { value: 3, done: false }
g.next() // { value: undefined, done: true }
&lt;/pre&gt;
&lt;p&gt;上面代码中，调用 Generator 函数，会返回一个内部指针（即遍历器 ）g 。这是 Generator 函数不同于普通函数的另一个地方，即执行它不会返回结果，返回的是指针对象。调用指针 g 的 next 方法，会移动内部指针（即执行异步任务的第一段），指向第一个遇到的 yield 语句，上例是执行到 x + 2 为止。&lt;/p&gt;
&lt;p&gt;换言之，next 方法的作用是分阶段执行 Generator 函数。每次调用 next 方法，会返回一个对象，表示当前阶段的信息（ value 属性和 done 属性）。value 属性是 yield 语句后面表达式的值，表示当前阶段的值；done 属性是一个布尔值，表示 Generator 函数是否执行完毕，即是否还有下一个阶段。&lt;/p&gt;
&lt;h2 id=&quot;generator-函数的数据交换和错误处理&quot;&gt;Generator 函数的数据交换和错误处理&lt;/h2&gt;
&lt;p&gt;Generator 函数可以暂停执行和恢复执行，这是它能封装异步任务的根本原因。除此之外，它还有两个特性，使它可以作为异步编程的完整解决方案：函数体内外的数据交换和错误处理机制。&lt;/p&gt;
&lt;p&gt;next 方法返回值的 value 属性，是 Generator 函数向外输出数据；next 方法还可以接受参数，这是向 Generator 函数体内输入数据。&lt;/p&gt;
&lt;pre class=&quot;prettyprint linenums lang-js&quot;&gt;function* gen(x){
    var y = yield x + 2;
  return y;
}

var g = gen(1);
g.next() // { value: 3, done: false }
g.next(2) // { value: 2, done: true }
&lt;/pre&gt;
&lt;p&gt;上面代码中，第一个 next 方法的 value 属性，返回表达式 x + 2 的值（3）。第二个 next 方法带有参数2，这个参数可以传入 Generator 函数，作为上个阶段异步任务的返回结果，被函数体内的变量 y 接收。因此，这一步的 value 属性，返回的就是2（变量 y 的值）。
Generator 函数内部还可以部署错误处理代码，捕获函数体外抛出的错误。&lt;/p&gt;
&lt;p&gt;Generator 函数内部还可以部署错误处理代码，捕获函数体外抛出的错误。&lt;/p&gt;
&lt;pre class=&quot;prettyprint linenums lang-js&quot;&gt;function* gen(x){
  try {
    var y = yield x + 2;
  } catch (e){ 
    console.log(e);
  }
  return y;
}

var g = gen(1);
g.next();
g.throw（&#39;出错了&#39;）;
// 出错了
&lt;/pre&gt;
&lt;p&gt;上面代码的最后一行，Generator 函数体外，使用指针对象的 throw 方法抛出的错误，可以被函数体内的 try ... catch 代码块捕获。这意味着，出错的代码与处理错误的代码，实现了时间和空间上的分离，这对于异步编程无疑是很重要的。&lt;/p&gt;
&lt;h2 id=&quot;generator-函数的用法&quot;&gt;Generator 函数的用法&lt;/h2&gt;
&lt;p&gt;下面看看如何使用 Generator 函数，执行一个真实的异步任务。&lt;/p&gt;
&lt;pre class=&quot;prettyprint linenums lang-js&quot;&gt;var fetch = require(&#39;node-fetch&#39;);

function* gen(){
  var url = &#39;https://api.github.com/users/github&#39;;
  var result = yield fetch(url);
  console.log(result.bio);
}
&lt;/pre&gt;
&lt;p&gt;上面代码中，Generator 函数封装了一个异步操作，该操作先读取一个远程接口，然后从 JSON 格式的数据解析信息。就像前面说过的，这段代码非常像同步操作，除了加上了 yield 命令。&lt;/p&gt;
&lt;p&gt;执行这段代码的方法如下。&lt;/p&gt;
&lt;pre class=&quot;prettyprint linenums lang-js&quot;&gt;var g = gen();
var result = g.next();

result.value.then(function(data){
  return data.json();
}).then(function(data){
  g.next(data);
});
&lt;/pre&gt;
&lt;p&gt;上面代码中，首先执行 Generator 函数，获取遍历器对象，然后使用 next 方法（第二行），执行异步任务的第一阶段。由于 Fetch 模块返回的是一个 Promise 对象，因此要用 then 方法调用下一个next 方法。&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>常见web安全攻防总结</title>
            <link>Homepage link/articles/web-security.html?utm_source=rss&amp;utm_medium=rss&amp;utm_campaign=rss</link>
            <guid>Homepage link/articles/web-security.html</guid>
            <author>chl01003698@126.com chuhongliang</author>
            <pubDate>Mon, 13 Apr 2020 00:00:00 +0800</pubDate>
            <description>&lt;h1 id=&quot;常见web安全攻防总结&quot;&gt;常见web安全攻防总结&lt;/h1&gt;
&lt;p&gt;常见的Web攻击类型有以下几种:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;XSS&lt;/li&gt;
&lt;li&gt;CSRF&lt;/li&gt;
&lt;li&gt;点击劫持&lt;/li&gt;
&lt;li&gt;URL跳转漏洞&lt;/li&gt;
&lt;li&gt;SQL注入&lt;/li&gt;
&lt;li&gt;OS命令注入攻击&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面来讲解每种攻击的原理以及防御的方法：&lt;/p&gt;
&lt;h1 id=&quot;一、xss&quot;&gt;一、XSS&lt;/h1&gt;
&lt;p&gt;XSS (Cross-Site Scripting)，跨站脚本攻击，因为缩写和 CSS重叠，所以只能叫 XSS。跨站脚本攻击是指通过存在安全漏洞的Web网站注册用户的浏览器内运行非法的HTML标签或JavaScript进行的一种攻击。&lt;/p&gt;
&lt;p&gt;XSS漏洞可以追溯到上世纪90年代。大量的网站曾遭受XSS漏洞攻击或被发现此类漏洞，如Twitter、Facebook、MySpace、Orkut、新浪微博和百度贴吧。研究表明，最近几年XSS已经超过缓冲区溢出成为最流行的攻击方式，有68%的网站可能遭受此类攻击。根据开放网页应用安全计划（Open Web Application Security Project）公布的2010年统计数据，在Web安全威胁前10位中，XSS排名第2，仅次于代码注入（Injection）。&lt;/p&gt;
&lt;p&gt;跨站脚本攻击有可能造成以下影响:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;利用虚假输入表单骗取用户个人信息。&lt;/li&gt;
&lt;li&gt;利用脚本窃取用户的Cookie值，被害者在不知情的情况下，帮助攻击者发送恶意请求。&lt;/li&gt;
&lt;li&gt;显示伪造的文章或图片。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;xss-的原理是恶意攻击者往-web-页面里插入恶意可执行网页脚本代码，当用户浏览该页之时，嵌入其中-web-里面的脚本代码会被执行，从而可以达到攻击者盗取用户信息或其他侵犯用户安全隐私的目的。&quot;&gt;XSS 的原理是恶意攻击者往 Web 页面里插入恶意可执行网页脚本代码，当用户浏览该页之时，嵌入其中 Web 里面的脚本代码会被执行，从而可以达到攻击者盗取用户信息或其他侵犯用户安全隐私的目的。&lt;/h4&gt;
&lt;p&gt;XSS主要分为两类：非持久型(反射型), 持久型(存储型)&lt;/p&gt;
&lt;h2 id=&quot;非持久型-xss&quot;&gt;非持久型 XSS&lt;/h2&gt;
&lt;p&gt;非持久型 XSS 漏洞，一般是通过给别人发送带有恶意脚本代码参数的 URL，当 URL 地址被打开时，特有的恶意代码参数被 HTML 解析、执行。&lt;/p&gt;
&lt;h3 id=&quot;非持久型-xss-漏洞攻击有以下几点特征：&quot;&gt;非持久型 XSS 漏洞攻击有以下几点特征：&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;即时性，不经过服务器存储，直接通过 HTTP 的 GET 和 POST 请求就能完成一次攻击，拿到用户隐私数据。&lt;/li&gt;
&lt;li&gt;攻击者需要诱骗点击,必须要通过用户点击链接才能发起&lt;/li&gt;
&lt;li&gt;反馈率低，所以较难发现和响应修复&lt;/li&gt;
&lt;li&gt;盗取用户敏感保密信息&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;例如：&quot;&gt;例如：&lt;/h4&gt;
&lt;p&gt;攻击者可以直接通过URL注入可执行的脚本代码。不过一些浏览器如Chrome其内置了一些XSS过滤器，可以防止大部分反射型XSS攻击。&lt;/p&gt;
&lt;pre class=&quot;prettyprint linenums lang-txt&quot;&gt;https://xxx.com/xxx?default=&lt;script&gt;alert(document.cookie)&lt;/script&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;为了防止出现非持久型-xss-漏洞，需要确保这么几件事情：&quot;&gt;为了防止出现非持久型 XSS 漏洞，需要确保这么几件事情：&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Web 页面渲染的所有内容或者渲染的数据都必须来自于服务端。&lt;/li&gt;
&lt;li&gt;尽量不要从 URL，document.referrer，document.forms 等这种 DOM API 中获取数据直接渲染。&lt;/li&gt;
&lt;li&gt;尽量不要使用 eval, new Function()，document.write()，document.writeln()，window.setInterval()，window.setTimeout()，innerHTML，document.createElement() 等可执行字符串的方法。&lt;/li&gt;
&lt;li&gt;如果做不到以上几点，也必须对涉及 DOM 渲染的方法传入的字符串参数做 escape 转义。&lt;/li&gt;
&lt;li&gt;前端渲染的时候对任何的字段都需要做 escape 转义编码。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;持久型-xss&quot;&gt;持久型 XSS&lt;/h2&gt;
&lt;p&gt;持久型 XSS 漏洞，一般存在于 Form 表单提交等交互功能，如文章留言，提交文本信息等，黑客利用的 XSS 漏洞，将内容经正常功能提交进入数据库持久保存，当前端页面获得后端从数据库中读出的注入代码时，恰好将其渲染执行。&lt;/p&gt;
&lt;p&gt;对于评论功能来说，就得防范持久型 XSS 攻击，因为我可以在评论中输入以下内容：&lt;/p&gt;
&lt;pre class=&quot;prettyprint linenums lang-txt&quot;&gt;&lt;script&gt;alert(1)&lt;/script&gt;
&lt;/pre&gt;
&lt;p&gt;主要注入页面方式和非持久型 XSS 漏洞类似，只不过持久型的不是来源于 URL，referer，forms 等，而是来源于后端从数据库中读出来的数据 。持久型 XSS 攻击不需要诱骗点击，黑客只需要在提交表单的地方完成注入即可，但是这种 XSS 攻击的成本相对还是很高。&lt;/p&gt;
&lt;h3 id=&quot;攻击成功需要同时满足以下几个条件：&quot;&gt;攻击成功需要同时满足以下几个条件：&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;POST 请求提交表单后端没做转义直接入库。&lt;/li&gt;
&lt;li&gt;后端从数据库中取出数据没做转义直接输出给前端。&lt;/li&gt;
&lt;li&gt;前端拿到后端数据没做转义直接渲染成 DOM。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;持久型-xss-有以下几个特点：&quot;&gt;持久型 XSS 有以下几个特点：&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;持久性，植入在数据库中&lt;/li&gt;
&lt;li&gt;盗取用户敏感私密信息&lt;/li&gt;
&lt;li&gt;危害面广&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;防御&quot;&gt;防御&lt;/h2&gt;
&lt;p&gt;对于 XSS 攻击来说，通常有两种方式可以用来防御。&lt;/p&gt;
&lt;h3 id=&quot;csp&quot;&gt;CSP&lt;/h3&gt;
&lt;p&gt;CSP 本质上就是建立白名单，开发者明确告诉浏览器哪些外部资源可以加载和执行。我们只需要配置规则，如何拦截是由浏览器自己实现的。我们可以通过这种方式来尽量减少 XSS 攻击。&lt;/p&gt;
&lt;h4 id=&quot;通常可以通过两种方式来开启-csp：&quot;&gt;通常可以通过两种方式来开启 CSP：&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;设置 HTTP Header 中的 Content-Security-Policy&lt;/li&gt;
&lt;li&gt;设置 meta 标签的方式&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;这里以设置-http-header-来举例：&quot;&gt;这里以设置 HTTP Header 来举例：&lt;/h4&gt;
&lt;p&gt;只允许加载本站资源&lt;/p&gt;
&lt;pre class=&quot;prettyprint linenums lang-js&quot;&gt;Content-Security-Policy: default-src &#39;self&#39;
&lt;/pre&gt;
&lt;p&gt;只允许加载 HTTPS 协议图片&lt;/p&gt;
&lt;pre class=&quot;prettyprint linenums lang-js&quot;&gt;Content-Security-Policy: img-src https://*
&lt;/pre&gt;
&lt;p&gt;允许加载任何来源框架&lt;/p&gt;
&lt;pre class=&quot;prettyprint linenums lang-js&quot;&gt;Content-Security-Policy: child-src &#39;none&#39;
&lt;/pre&gt;
&lt;h4 id=&quot;如需了解更多属性，请查看-a-href-https-developermozillaorg-zh-cn-docs-web-http-headers-content-security-policy-content-security-policy文档-a-&quot;&gt;如需了解更多属性，请查看&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Security-Policy&quot;&gt;Content-Security-Policy文档&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;对于这种方式来说，只要开发者配置了正确的规则，那么即使网站存在漏洞，攻击者也不能执行它的攻击代码，并且 CSP 的兼容性也不错。&lt;/p&gt;
&lt;h3 id=&quot;转义字符&quot;&gt;转义字符&lt;/h3&gt;
&lt;p&gt;用户的输入永远不可信任的，最普遍的做法就是转义输入输出的内容，对于引号、尖括号、斜杠进行转义&lt;/p&gt;
&lt;pre class=&quot;prettyprint linenums lang-js&quot;&gt;function escape(str) {
  str = str.replace(/&amp;/g, &#39;&amp;amp;&#39;)
  str = str.replace(/&lt;/g, &#39;&amp;lt;&#39;)
  str = str.replace(/&gt;/g, &#39;&amp;gt;&#39;)
  str = str.replace(/&quot;/g, &#39;&amp;quto;&#39;)
  str = str.replace(/&#39;/g, &#39;&amp;#39;&#39;)
  str = str.replace(/`/g, &#39;&amp;#96;&#39;)
  str = str.replace(/\//g, &#39;&amp;#x2F;&#39;)
  return str
}
&lt;/pre&gt;
&lt;p&gt;但是对于显示富文本来说，显然不能通过上面的办法来转义所有字符，因为这样会把需要的格式也过滤掉。对于这种情况，通常采用白名单过滤的办法，当然也可以通过黑名单过滤，但是考虑到需要过滤的标签和标签属性实在太多，更加推荐使用白名单的方式。&lt;/p&gt;
&lt;pre class=&quot;prettyprint linenums lang-js&quot;&gt;const xss = require(&#39;xss&#39;)
let html = xss(&#39;&lt;h1 id=&quot;title&quot;&gt;XSS Demo&lt;/h1&gt;&lt;script&gt;alert(&quot;xss&quot;);&lt;/script&gt;&#39;)
// -&gt; &lt;h1&gt;XSS Demo&lt;/h1&gt;&amp;lt;script&amp;gt;alert(&quot;xss&quot;);&amp;lt;/script&amp;gt;
console.log(html)
&lt;/pre&gt;
&lt;p&gt;以上示例使用了 js-xss 来实现，可以看到在输出中保留了 h1 标签且过滤了 script 标签。&lt;/p&gt;
&lt;h3 id=&quot;httponly-cookie。&quot;&gt;HttpOnly Cookie。&lt;/h3&gt;
&lt;p&gt;这是预防XSS攻击窃取用户cookie最有效的防御手段。Web应用程序在设置cookie时，将其属性设为HttpOnly，就可以避免该网页的cookie被客户端恶意JavaScript窃取，保护用户cookie信息。&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&quot;二、csrf&quot;&gt;二、CSRF&lt;/h1&gt;
&lt;p&gt;CSRF(Cross Site Request Forgery)，即跨站请求伪造，是一种常见的Web攻击，它利用用户已登录的身份，在用户毫不知情的情况下，以用户的名义完成非法操作。&lt;/p&gt;
&lt;h2 id=&quot;csrf攻击的原理&quot;&gt;CSRF攻击的原理&lt;/h2&gt;
&lt;h3 id=&quot;完成-csrf-攻击必须要有三个条件：&quot;&gt;完成 CSRF 攻击必须要有三个条件：&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;用户已经登录了站点 A，并在本地记录了 cookie&lt;/li&gt;
&lt;li&gt;在用户没有登出站点 A 的情况下（也就是 cookie 生效的情况下），访问了恶意攻击者提供的引诱危险站点 B (B 站点要求访问站点A)。&lt;/li&gt;
&lt;li&gt;站点 A 没有做任何 CSRF 防御&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我们来看一个例子： 当我们登入转账页面后，突然眼前一亮惊现&quot;XXX隐私照片，不看后悔一辈子&quot;的链接，耐不住内心躁动，立马点击了该危险的网站（页面代码如下图所示），但当这页面一加载，便会执行submitForm这个方法来提交转账请求，从而将10块转给黑客。&lt;/p&gt;
&lt;h2 id=&quot;防御&quot;&gt;防御&lt;/h2&gt;
&lt;h3 id=&quot;防范-csrf-攻击可以遵循以下几种规则：z&quot;&gt;防范 CSRF 攻击可以遵循以下几种规则：z&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Get 请求不对数据进行修改&lt;/li&gt;
&lt;li&gt;不让第三方网站访问到用户 Cookie&lt;/li&gt;
&lt;li&gt;阻止第三方网站请求接口&lt;/li&gt;
&lt;li&gt;请求时附带验证信息，比如验证码或者 Token&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;samesite&quot;&gt;SameSite&lt;/h3&gt;
&lt;p&gt;可以对 Cookie 设置 SameSite 属性。该属性表示 Cookie 不随着跨域请求发送，可以很大程度减少 CSRF 的攻击，但是该属性目前并不是所有浏览器都兼容。&lt;/p&gt;
&lt;h3 id=&quot;referer-check&quot;&gt;Referer Check&lt;/h3&gt;
&lt;p&gt;HTTP Referer是header的一部分，当浏览器向web服务器发送请求时，一般会带上Referer信息告诉服务器是从哪个页面链接过来的，服务器籍此可以获得一些信息用于处理。可以通过检查请求的来源来防御CSRF攻击。正常请求的referer具有一定规律，如在提交表单的referer必定是在该页面发起的请求。所以通过检查http包头referer的值是不是这个页面，来判断是不是CSRF攻击。&lt;/p&gt;
&lt;p&gt;但在某些情况下如从https跳转到http，浏览器处于安全考虑，不会发送referer，服务器就无法进行check了。若与该网站同域的其他网站有XSS漏洞，那么攻击者可以在其他网站注入恶意脚本，受害者进入了此类同域的网址，也会遭受攻击。出于以上原因，无法完全依赖Referer Check作为防御CSRF的主要手段。但是可以通过Referer Check来监控CSRF攻击的发生。&lt;/p&gt;
&lt;h3 id=&quot;anti-csrf-token&quot;&gt;Anti CSRF Token&lt;/h3&gt;
&lt;p&gt;目前比较完善的解决方案是加入Anti-CSRF-Token。即发送请求时在HTTP 请求中以参数的形式加入一个随机产生的token，并在服务器建立一个拦截器来验证这个token。服务器读取浏览器当前域cookie中这个token值，会进行校验该请求当中的token和cookie当中的token值是否都存在且相等，才认为这是合法的请求。否则认为这次请求是违法的，拒绝该次服务。&lt;/p&gt;
&lt;p&gt;这种方法相比Referer检查要安全很多，token可以在用户登陆后产生并放于session或cookie中，然后在每次请求时服务器把token从session或cookie中拿出，与本次请求中的token 进行比对。由于token的存在，攻击者无法再构造出一个完整的URL实施CSRF攻击。但在处理多个页面共存问题时，当某个页面消耗掉token后，其他页面的表单保存的还是被消耗掉的那个token，其他页面的表单提交时会出现token错误。&lt;/p&gt;
&lt;h3 id=&quot;验证码&quot;&gt;验证码&lt;/h3&gt;
&lt;p&gt;应用程序和用户进行交互过程中，特别是账户交易这种核心步骤，强制用户输入验证码，才能完成最终请求。在通常情况下，验证码够很好地遏制CSRF攻击。但增加验证码降低了用户的体验，网站不能给所有的操作都加上验证码。所以只能将验证码作为一种辅助手段，在关键业务点设置验证码。&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&quot;三、点击劫持&quot;&gt;三、点击劫持&lt;/h1&gt;
&lt;p&gt;点击劫持是一种视觉欺骗的攻击手段。攻击者将需要攻击的网站通过 iframe 嵌套的方式嵌入自己的网页中，并将 iframe 设置为透明，在页面中透出一个按钮诱导用户点击。&lt;/p&gt;
&lt;h2 id=&quot;特点&quot;&gt;特点&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;隐蔽性较高，骗取用户操作&lt;/li&gt;
&lt;li&gt;&quot;UI-覆盖攻击&quot;&lt;/li&gt;
&lt;li&gt;利用iframe或者其它标签的属性&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;点击劫持的原理&quot;&gt;点击劫持的原理&lt;/h2&gt;
&lt;p&gt;用户在登陆 A 网站的系统后，被攻击者诱惑打开第三方网站，而第三方网站通过 iframe 引入了 A 网站的页面内容，用户在第三方网站中点击某个按钮（被装饰的按钮），实际上是点击了 A 网站的按钮。
接下来我们举个例子：我在优酷发布了很多视频，想让更多的人关注它，就可以通过点击劫持来实现&lt;/p&gt;
&lt;pre class=&quot;prettyprint linenums lang-txt&quot;&gt;iframe {
  width: 1440px;
  height: 900px;
  position: absolute;
  top: -0px;
  left: -0px;
  z-index: 2;
  -moz-opacity: 0;
  opacity: 0;
  filter: alpha(opacity=0);
}
button {
  position: absolute;
  top: 270px;
  left: 1150px;
  z-index: 1;
  width: 90px;
  height:40px;
}
&lt;/style&gt;
......
&lt;button&gt;点击脱衣&lt;/button&gt;
&lt;img src=&quot;http://pic1.win4000.com/wallpaper/2018-03-19/5aaf2bf0122d2.jpg&quot;&gt;
&lt;iframe src=&quot;http://i.youku.com/u/UMjA0NTg4Njcy&quot; scrolling=&quot;no&quot;&gt;&lt;/iframe&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;从上图可知，攻击者通过图片作为页面背景，隐藏了用户操作的真实界面，当你按耐不住好奇点击按钮以后，真正的点击的其实是隐藏的那个页面的订阅按钮，然后就会在你不知情的情况下订阅了。&quot;&gt;从上图可知，攻击者通过图片作为页面背景，隐藏了用户操作的真实界面，当你按耐不住好奇点击按钮以后，真正的点击的其实是隐藏的那个页面的订阅按钮，然后就会在你不知情的情况下订阅了。&lt;/h4&gt;
&lt;h2 id=&quot;防御&quot;&gt;防御&lt;/h2&gt;
&lt;h3 id=&quot;x-frame-options&quot;&gt;X-FRAME-OPTIONS&lt;/h3&gt;
&lt;p&gt;X-FRAME-OPTIONS是一个 HTTP 响应头，在现代浏览器有一个很好的支持。这个 HTTP 响应头 就是为了防御用 iframe 嵌套的点击劫持攻击。&lt;/p&gt;
&lt;h4 id=&quot;该响应头有三个值可选，分别是-&quot;&gt;该响应头有三个值可选，分别是:&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;DENY，表示页面不允许通过 iframe 的方式展示&lt;/li&gt;
&lt;li&gt;SAMEORIGIN，表示页面可以在相同域名下通过 iframe 的方式展示&lt;/li&gt;
&lt;li&gt;ALLOW-FROM，表示页面可以在指定来源的 iframe 中展示&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;javascript-防御&quot;&gt;JavaScript 防御&lt;/h3&gt;
&lt;p&gt;对于某些远古浏览器来说，并不能支持上面的这种方式，那我们只有通过 JS 的方式来防御点击劫持了。&lt;/p&gt;
&lt;pre class=&quot;prettyprint linenums lang-txt&quot;&gt;&lt;head&gt;
  &lt;style id=&quot;click-jack&quot;&gt;
    html {
      display: none !important;
    }
  &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;script&gt;
    if (self == top) {
      var style = document.getElementById(&#39;click-jack&#39;)
      document.body.removeChild(style)
    } else {
      top.location = self.location
    }
  &lt;/script&gt;
&lt;/body&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;以上代码的作用就是当通过-iframe-的方式加载页面时，攻击者的网页直接不显示所有内容了。&quot;&gt;以上代码的作用就是当通过 iframe 的方式加载页面时，攻击者的网页直接不显示所有内容了。&lt;/h4&gt;
&lt;hr&gt;
&lt;h1 id=&quot;四、url跳转漏洞&quot;&gt;四、URL跳转漏洞&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;定义：借助未验证的URL跳转，将应用程序引导到不安全的第三方区域，从而导致的安全问题。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;url跳转漏洞原理&quot;&gt;URL跳转漏洞原理&lt;/h2&gt;
&lt;p&gt;黑客利用URL跳转漏洞来诱导安全意识低的用户点击，导致用户信息泄露或者资金的流失。其原理是黑客构建恶意链接(链接需要进行伪装,尽可能迷惑),发在QQ群或者是浏览量多的贴吧/论坛中。
安全意识低的用户点击后,经过服务器或者浏览器解析后，跳到恶意的网站中。&lt;/p&gt;
&lt;p&gt;恶意链接需要进行伪装,经常的做法是熟悉的链接后面加上一个恶意的网址，这样才迷惑用户。&lt;/p&gt;
&lt;p&gt;诸如伪装成像如下的网址，你是否能够识别出来是恶意网址呢？&lt;/p&gt;
&lt;pre class=&quot;prettyprint linenums lang-txt&quot;&gt;http://gate.baidu.com/index?act=go&amp;url=http://t.cn/RVTatrd
http://qt.qq.com/safecheck.html?flag=1&amp;url=http://t.cn/RVTatrd
http://tieba.baidu.com/f/user/passport?jumpUrl=http://t.cn/RVTatrd
&lt;/pre&gt;
&lt;h2 id=&quot;实现方式：&quot;&gt;实现方式：&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Header头跳转&lt;/li&gt;
&lt;li&gt;Javascript跳转&lt;/li&gt;
&lt;li&gt;META标签跳转&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;这里我们举个header头跳转实现方式：&quot;&gt;这里我们举个Header头跳转实现方式：&lt;/h3&gt;
&lt;pre class=&quot;prettyprint linenums lang-php&quot;&gt;&lt;?php
$url=$_GET[&#39;jumpto&#39;];
header(&quot;Location: $url&quot;);
?&gt;
&lt;/pre&gt;
&lt;pre class=&quot;prettyprint linenums lang-txt&quot;&gt;http://www.wooyun.org/login.php?jumpto=http://www.evil.com
&lt;/pre&gt;
&lt;p&gt;这里用户会认为&lt;a href=&quot;http://www.wooyun.org都是可信的，但是点击上述链接将导致用户最终访问www.evil.com这个恶意网址。&quot;&gt;www.wooyun.org都是可信的，但是点击上述链接将导致用户最终访问www.evil.com这个恶意网址。&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;防御&quot;&gt;防御&lt;/h2&gt;
&lt;h3 id=&quot;referer的限制&quot;&gt;referer的限制&lt;/h3&gt;
&lt;p&gt;如果确定传递URL参数进入的来源，我们可以通过该方式实现安全限制，保证该URL的有效性，避免恶意用户自己生成跳转链接&lt;/p&gt;
&lt;h3 id=&quot;加入有效性验证token&quot;&gt;加入有效性验证Token&lt;/h3&gt;
&lt;p&gt;我们保证所有生成的链接都是来自于我们可信域的，通过在生成的链接里加入用户不可控的Token对生成的链接进行校验，可以避免用户生成自己的恶意链接从而被利用，但是如果功能本身要求比较开放，可能导致有一定的限制。&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&quot;五、sql注入&quot;&gt;五、SQL注入&lt;/h1&gt;
&lt;p&gt;SQL注入是一种常见的Web安全漏洞，攻击者利用这个漏洞，可以访问或修改数据，或者利用潜在的数据库漏洞进行攻击。&lt;/p&gt;
&lt;h2 id=&quot;sql注入的原理&quot;&gt;SQL注入的原理&lt;/h2&gt;
&lt;h4 id=&quot;我们先举一个万能钥匙的例子来说明其原理：&quot;&gt;我们先举一个万能钥匙的例子来说明其原理：&lt;/h4&gt;
&lt;pre class=&quot;prettyprint linenums lang-js&quot;&gt;&lt;form action=&quot;/login&quot; method=&quot;POST&quot;&gt;
  &lt;p&gt;Username: &lt;input type=&quot;text&quot; name=&quot;username&quot; /&gt;&lt;/p&gt;
  &lt;p&gt;Password: &lt;input type=&quot;password&quot; name=&quot;password&quot; /&gt;&lt;/p&gt;
  &lt;p&gt;&lt;input type=&quot;submit&quot; value=&quot;登陆&quot; /&gt;&lt;/p&gt;
&lt;/form&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;后端的-sql-语句可能是如下这样的：&quot;&gt;后端的 SQL 语句可能是如下这样的：&lt;/h4&gt;
&lt;pre class=&quot;prettyprint linenums lang-js&quot;&gt;let querySQL = `
    SELECT *
    FROM user
    WHERE username=&#39;${username}&#39;
    AND psw=&#39;${password}&#39;
`;
// 接下来就是执行 sql 语句...
&lt;/pre&gt;
&lt;p&gt;这是我们经常见到的登录页面，但如果有一个恶意攻击者输入的用户名是 admin&#39; --，密码随意输入，就可以直接登入系统了。why! ----这就是SQL注入&lt;/p&gt;
&lt;p&gt;我们之前预想的SQL 语句是:&lt;/p&gt;
&lt;pre class=&quot;prettyprint linenums lang-sql&quot;&gt;SELECT * FROM user WHERE username=&#39;admin&#39; AND psw=&#39;password&#39;
&lt;/pre&gt;
&lt;p&gt;但是恶意攻击者用奇怪用户名将你的 SQL 语句变成了如下形式：&lt;/p&gt;
&lt;pre class=&quot;prettyprint linenums lang-sql&quot;&gt;SELECT * FROM user WHERE username=&#39;admin&#39;
&lt;/pre&gt;
&lt;p&gt;所谓的万能密码,本质上就是SQL注入的一种利用方式。&lt;/p&gt;
&lt;h3 id=&quot;一次sql注入的过程包括以下几个过程：&quot;&gt;一次SQL注入的过程包括以下几个过程：&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;获取用户请求参数&lt;/li&gt;
&lt;li&gt;拼接到代码当中&lt;/li&gt;
&lt;li&gt;SQL语句按照我们构造参数的语义执行成功&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;sql注入的必备条件：&quot;&gt;SQL注入的必备条件：&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;可以控制输入的数据&lt;/li&gt;
&lt;li&gt;服务器要执行的代码拼接了控制的数据。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我们会发现SQL注入流程中与正常请求服务器类似，只是黑客控制了数据，构造了SQL查询，而正常的请求不会SQL查询这一步，SQL注入的本质:数据和代码未分离，即数据当做了代码来执行。&lt;/p&gt;
&lt;h2 id=&quot;危害&quot;&gt;危害&lt;/h2&gt;
&lt;h3 id=&quot;获取数据库信息&quot;&gt;获取数据库信息&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;管理员后台用户名和密码&lt;/li&gt;
&lt;li&gt;获取其他数据库敏感信息：用户名、密码、手机号码、身份证、银行卡信息……&lt;/li&gt;
&lt;li&gt;整个数据库：脱裤&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;获取服务器权限&quot;&gt;获取服务器权限&lt;/h4&gt;
&lt;h4 id=&quot;植入webshell，获取服务器后门&quot;&gt;植入Webshell，获取服务器后门&lt;/h4&gt;
&lt;h4 id=&quot;读取服务器敏感文件&quot;&gt;读取服务器敏感文件&lt;/h4&gt;
&lt;h2 id=&quot;防御&quot;&gt;防御&lt;/h2&gt;
&lt;p&gt;严格限制Web应用的数据库的操作权限，给此用户提供仅仅能够满足其工作的最低权限，从而最大限度的减少注入攻击对数据库的危害&lt;/p&gt;
&lt;p&gt;后端代码检查输入的数据是否符合预期，严格限制变量的类型，例如使用正则表达式进行一些匹配处理。&lt;/p&gt;
&lt;p&gt;对进入数据库的特殊字符（&#39;，&quot;，\，&lt;，&gt;，&amp;，*，; 等）进行转义处理，或编码转换。基本上所有的后端语言都有对字符串进行转义处理的方法，比如 lodash 的 lodash._escapehtmlchar 库。&lt;/p&gt;
&lt;p&gt;所有的查询语句建议使用数据库提供的参数化查询接口，参数化的语句使用参数而不是将用户输入变量嵌入到 SQL 语句中，即不要直接拼接 SQL 语句。例如 Node.js 中的 mysqljs 库的 query 方法中的 ? 占位参数。&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&quot;六、os命令注入攻击&quot;&gt;六、OS命令注入攻击&lt;/h1&gt;
&lt;p&gt;OS命令注入和SQL注入差不多，只不过SQL注入是针对数据库的，而OS命令注入是针对操作系统的。OS命令注入攻击指通过Web应用，执行非法的操作系统命令达到攻击的目的。只要在能调用Shell函数的地方就有存在被攻击的风险。倘若调用Shell时存在疏漏，就可以执行插入的非法命令。&lt;/p&gt;
&lt;p&gt;命令注入攻击可以向Shell发送命令，让Windows或Linux操作系统的命令行启动程序。也就是说，通过命令注入攻击可执行操作系统上安装着的各种程序。&lt;/p&gt;
&lt;h2 id=&quot;原理&quot;&gt;原理&lt;/h2&gt;
&lt;p&gt;黑客构造命令提交给web应用程序，web应用程序提取黑客构造的命令，拼接到被执行的命令中，因黑客注入的命令打破了原有命令结构，导致web应用执行了额外的命令，最后web应用程序将执行的结果输出到响应页面中。&lt;/p&gt;
&lt;p&gt;我们通过一个例子来说明其原理，假如需要实现一个需求：用户提交一些内容到服务器，然后在服务器执行一些系统命令去返回一个结果给用户&lt;/p&gt;
&lt;pre class=&quot;prettyprint linenums lang-js&quot;&gt;// 以 Node.js 为例，假如在接口中需要从 github 下载用户指定的 repo
const exec = require(&#39;mz/child_process&#39;).exec;
let params = {/* 用户输入的参数 */};
exec(`git clone ${params.repo} /some/path`);
&lt;/pre&gt;
&lt;p&gt;如果 params.repo 传入的是 &lt;a href=&quot;https://github.com/admin/admin.github.io.git&quot;&gt;https://github.com/admin/admin.github.io.git&lt;/a&gt; 确实能从指定的 git repo 上下载到想要的代码。
但是如果 params.repo 传入的是 &lt;a href=&quot;https://github.com/xx/xx.git&quot;&gt;https://github.com/xx/xx.git&lt;/a&gt; &amp;&amp; rm -rf /* &amp;&amp; 恰好你的服务是用 root 权限起的就糟糕了。&lt;/p&gt;
&lt;h2 id=&quot;防御&quot;&gt;防御&lt;/h2&gt;
&lt;p&gt;后端对前端提交内容进行规则限制（比如正则表达式）。&lt;/p&gt;
&lt;p&gt;在调用系统命令前对所有传入参数进行命令行参数转义过滤。&lt;/p&gt;
&lt;p&gt;不要直接拼接命令语句，借助一些工具做拼接、转义预处理，例如 Node.js 的 shell-escape npm包&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>Node.js 实现简单的静态服务器</title>
            <link>Homepage link/articles/node-static.html?utm_source=rss&amp;utm_medium=rss&amp;utm_campaign=rss</link>
            <guid>Homepage link/articles/node-static.html</guid>
            <author>chl01003698@126.com chuhongliang</author>
            <pubDate>Sat, 11 Apr 2020 00:00:00 +0800</pubDate>
            <description>&lt;h1 id=&quot;node-实现简单的静态服务器&quot;&gt;Node 实现简单的静态服务器&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;Node里面是没有Web容器的概念, 所以URL上的路径跟实际文件的路径并不一致。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这里我们手动实现一个简单的原生静态服务，让Node能够找到路径的文件，实现静态服务器功能。文件夹的任何文件都能被找到。&lt;/p&gt;
&lt;pre class=&quot;prettyprint linenums lang-js&quot;&gt;const http = require(&quot;http&quot;);
const url = require(&quot;url&quot;);
const fs = require(&quot;fs&quot;);
const path = require(&quot;path&quot;);

http.createServer(function (req, res) {
    //得到用户的路径
    let pathname = url.parse(req.url).pathname;
    if (pathname == &quot;/&quot;) {
        pathname = &quot;index.html&quot;;
    }
    //拓展名
    let extname = path.extname(pathname);
    //读取文件
    fs.readFile(&quot;./public/&quot; + pathname, function (err, data) {
        //data是一个Buffer，二进制的数据流
        if (err) {
            //如果文件不存在，就返回404
            fs.readFile(&quot;./public/404.html&quot;, function (err, data) {
                res.writeHead(404, { &quot;Content-type&quot;: &quot;text/html;chaset=utf-8&quot; });
                res.end(data);
            });
            return;
        }
        //MIME类型，就是
        let mime = getMIME(extname)
        res.writeHead(200, { &quot;Content-type&quot;: mime });
        res.end(data);
    })
}).listen(3000, &quot;127.0.0.1&quot;, function () {
    console.log(&#39;http://127.0.0.1:3000&#39;);
});
&lt;/pre&gt;
&lt;h4 id=&quot;对不同的文件进行不同的响应头处理&quot;&gt;对不同的文件进行不同的响应头处理&lt;/h4&gt;
&lt;pre class=&quot;prettyprint linenums lang-js&quot;&gt;function getMIME(extname) {
    switch (extname) {
        case &quot;.html&quot;:
            return &quot;text/html;chaset=utf-8&quot;;
        case &quot;.jpg&quot;:
            return &quot;image/jpg&quot;;
        case &quot;.css&quot;:
            return &quot;text/css&quot;;
    }
}
&lt;/pre&gt;
</description>
        </item>
        
        <item>
            <title>JavaScript 柯里化</title>
            <link>Homepage link/articles/javascript-curry.html?utm_source=rss&amp;utm_medium=rss&amp;utm_campaign=rss</link>
            <guid>Homepage link/articles/javascript-curry.html</guid>
            <author>chl01003698@126.com chuhongliang</author>
            <pubDate>Wed, 08 Apr 2020 00:00:00 +0800</pubDate>
            <description>&lt;h1 id=&quot;javascript-柯里化（currying）&quot;&gt;JavaScript 柯里化（Currying）&lt;/h1&gt;
&lt;p&gt;在计算机科学中，柯里化（Currying）是把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数且返回结果的新函数的技术。这个技术由 Christopher Strachey 以逻辑学家 Haskell Curry 命名的，尽管它是 Moses Schnfinkel 和 Gottlob Frege 发明的。&lt;/p&gt;
&lt;h2 id=&quot;柯里化示例：&quot;&gt;柯里化示例：&lt;/h2&gt;
&lt;pre class=&quot;prettyprint linenums lang-js&quot;&gt;// 正常正则验证字符串 reg.test(txt)
// 函数封装后
function check(reg, txt) {
    return reg.test(txt)
}

check(/\d+/g, &#39;test&#39;)       //false
check(/[a-z]+/g, &#39;test&#39;)    //true

// Currying后
function curryingCheck(reg) {
    return function(txt) {
        return reg.test(txt)
    }
}

var hasNumber = curryingCheck(/\d+/g)
var hasLetter = curryingCheck(/[a-z]+/g)

hasNumber(&#39;test1&#39;)      // true
hasNumber(&#39;testtest&#39;)   // false
hasLetter(&#39;21212&#39;)      // false
&lt;/pre&gt;
&lt;p&gt;这里表明的是一种“预加载”函数的能力，通过传递一到两个参数调用函数，就能得到一个记住了这些参数的新函数。&lt;/p&gt;
&lt;p&gt;只传给函数一部分参数通常也叫做局部调用（partial application），能够大量减少样板文件代码.&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>JavaScript Promise</title>
            <link>Homepage link/articles/javascript-promise.html?utm_source=rss&amp;utm_medium=rss&amp;utm_campaign=rss</link>
            <guid>Homepage link/articles/javascript-promise.html</guid>
            <author>chl01003698@126.com chuhongliang</author>
            <pubDate>Tue, 07 Apr 2020 00:00:00 +0800</pubDate>
            <description>&lt;h1 id=&quot;promise&quot;&gt;Promise&lt;/h1&gt;
&lt;p&gt;Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。它由社区最早提出和实现，ES6 将其写进了语言标准，统一了用法，原生提供了Promise对象。&lt;/p&gt;
&lt;p&gt;所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。&lt;/p&gt;
&lt;h2 id=&quot;promise对象有以下两个特点。&quot;&gt;Promise对象有以下两个特点。&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;对象的状态不受外界影响。Promise对象代表一个异步操作，有三种状态：pending（进行中）、fulfilled（已成功）和rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是Promise这个名字的由来，它的英语意思就是“承诺”，表示其他手段无法改变。&lt;/li&gt;
&lt;li&gt;一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise对象的状态改变，只有两种可能：从pending变为fulfilled和从pending变为rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果，这时就称为 resolved（已定型）。如果改变已经发生了，你再对Promise对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;有了Promise对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。此外，Promise对象提供统一的接口，使得控制异步操作更加容易。&lt;/p&gt;
&lt;p&gt;Promise也有一些缺点。首先，无法取消Promise，一旦新建它就会立即执行，无法中途取消。其次，如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。第三，当处于pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;以上摘自&lt;a href=&quot;https://es6.ruanyifeng.com/#docs/promise&quot;&gt;ECMAScript 6 入门&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h1 id=&quot;promise标准&quot;&gt;Promise标准&lt;/h1&gt;
&lt;p&gt;Promise 规范有很多，如Promise/A，Promise/B，Promise/D 以及 Promise/A 的升级版 Promise/A+。ES6 中采用了 Promise/A+ 规范。&lt;/p&gt;
&lt;p&gt;英文版规范: &lt;a href=&quot;https://promisesaplus.com/&quot;&gt;Promises/A+规范&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;中文版规范: &lt;a href=&quot;https://www.ituring.com.cn/article/66566&quot;&gt;Promises/A+规范(中文)&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&quot;promise-原理与实现&quot;&gt;Promise 原理与实现&lt;/h1&gt;
&lt;h2 id=&quot;构造函数&quot;&gt;构造函数&lt;/h2&gt;
&lt;pre class=&quot;prettyprint linenums lang-js&quot;&gt;function Promise(executor){};
&lt;/pre&gt;
&lt;h2 id=&quot;原型方法&quot;&gt;原型方法&lt;/h2&gt;
&lt;pre class=&quot;prettyprint linenums lang-js&quot;&gt;Promise.prototype.then = function() {}
Promise.prototype.catch = function() {}
&lt;/pre&gt;
&lt;h2 id=&quot;静态方法&quot;&gt;静态方法&lt;/h2&gt;
&lt;pre class=&quot;prettyprint linenums lang-js&quot;&gt;Promise.resolve = function() {}
Promise.reject = function() {}
Promise.all = function() {}
Promise.race = function() {}
&lt;/pre&gt;
&lt;h2 id=&quot;promise实现原理-&quot;&gt;Promise实现原理:&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;构造函数接收一个executor立即执行函数&lt;/li&gt;
&lt;li&gt;executor立即执行函数接收两个参数resolve, reject&lt;/li&gt;
&lt;li&gt;promise对象的then方法绑定状态变为fulfilled时的回调&lt;/li&gt;
&lt;li&gt;resolve函数被调用时会触发then方法中的回调&lt;/li&gt;
&lt;li&gt;reject函数被调用时会触发catch方法中的回调&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;下面为代码实现-&quot;&gt;下面为代码实现:&lt;/h3&gt;
&lt;pre class=&quot;prettyprint linenums lang-js&quot;&gt;const PENDING = &#39;pending&#39;;
const RESOLEVED = &#39;resolved&#39;;
const REJECTED = &#39;rejected&#39;;

function Promise(executor) {
    const self = this;
    self.state = PENDING;
    self.data = undefined; //promise的值
    self.resolvedCallback = [];
    self.rejectedCallback = [];

    function resolve(value) {
        if (self.status === PENDING) {
            self.status = RESOLEVED;
            self.data = value;
            self.resolvedCallback.forEach(function (callback) {
                callback(value);
            });
        }
    }

    function reject(reason) {
        if (self.status === PENDING) {
            self.status = REJECTED;
            self.data = reason;
            self.rejectedCallback.forEach(function (callback) {
                callback(reason);
            });
        }
    }

    try {
        executor(resolve, reject);
    } catch (e) {
        // 执行器出现错误需要reject
        reject(e)
    }
}

Promise.prototype.then = function (onFulfilled, onRejected) {
    const { state, value, resolvedCallback, rejectedCallback } = this;
    return new Promise((resolveNext, rejectNext) =&gt; {
        const resolvePromise = value =&gt; {
            try {
                // 正常情况
                if (typeof onFulfilled !== &#39;function&#39;) {
                    // 不是函数，直接忽略，将then所属的promise作为then返回的promise的值resolve来做到值的传递
                    resolveNext(value)
                } else {
                    // 获取then函数回调的执行结果
                    const res = onFulfilled(value)
                    if (res instanceof NewPromise) {
                        // 当执行结果返回的是一个promise实例，等待这个promise状态改变后再改变then返回的promise的状态
                        res.then(resolveNext, rejectNext)
                    } else {
                        // 当返回值是普通值，将其作为新promise的值resolve
                        resolveNext(res)
                    }
                }
            } catch (e) {
                // 出现异常，新promise的状态变为rejected，reason就是错误对象
                rejectNext(e)
            }
        }
        const rejectPromise = reason =&gt; {
            try {
                // 正常情况
                if (typeof onRejected !== &#39;function&#39;) {
                    // 不是函数，直接忽略，将then所属的promise作为then返回的promise的值reject来做到值的传递
                    rejectNext(reason)
                } else {
                    // 获取then函数回调的执行结果
                    const res = onRejected(reason)
                    if (res instanceof NewPromise) {
                        // 当执行结果返回的是一个promise实例，等待这个promise状态改变后再改变then返回的promise的状态
                        res.then(resolveNext, rejectNext)
                    } else {
                        // 当返回值是普通值，将其作为新promise的值reject
                        rejectNext(res)
                    }
                }
            } catch (e) {
                // 出现异常，新promise的状态变为rejected，reason就是错误对象
                rejectNext(e)
            }
        }
        if (state === PENDING) {
            resolvedCallback.push(resolvePromise)
            rejectedCallback.push(rejectPromise)
        }
        // 要保证在当前promise状态改变之后，再去改变新的promise的状态
        if (state === RESOLEVED) {
            resolvePromise(value)
        }
        if (state === REJECTED) {
            rejectPromise(value)
        }
    })
}

// 用then方法实现catch
Promise.prototype.catch = function (reject) {
  return this.then(null, reject);
}
&lt;/pre&gt;
&lt;h3 id=&quot;加入异步机制-&quot;&gt;加入异步机制:&lt;/h3&gt;
&lt;pre class=&quot;prettyprint linenums lang-js&quot;&gt;function resolve(value) {
    setTimeout(function () {
        if (self.status === PENDING) {
            self.status = RESOLEVED;
            self.data = value;
            self.resolvedCallback.forEach(function (callback) {
                callback(value);
            });
        }
    }, 0)
}

function reject(reason) {
    setTimeout(function () {
        if (self.status === PENDING) {
            self.status = REJECTED;
            self.data = reason;
            self.rejectedCallback.forEach(function (callback) {
                callback(reason);
            });
        }
    }, 0)
}
&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;实际上，真正的promise库不倾向于使用setTimeout。如果库是面向NodeJS的，它可能会使用process.nextTick，对于浏览器，它可能会使用新的setImmediate或setImmediate shim（目前只有IE支持setImmediate），或者可能是异步库，如Kris Kowal的asap（Kris Kowal还编写了Q，一个流行的promise库）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;p&gt;参考:&lt;a href=&quot;http://www.mattgreer.org/articles/promises-in-wicked-detail/&quot;&gt;mattgreer&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>面试遇到的算法</title>
            <link>Homepage link/articles/algorithm-interview.html?utm_source=rss&amp;utm_medium=rss&amp;utm_campaign=rss</link>
            <guid>Homepage link/articles/algorithm-interview.html</guid>
            <author>chl01003698@126.com chuhongliang</author>
            <pubDate>Mon, 30 Mar 2020 00:00:00 +0800</pubDate>
            <description>&lt;h2 id=&quot;面试遇到的算法题&quot;&gt;面试遇到的算法题&lt;/h2&gt;
&lt;h3 id=&quot;简单的字符串压缩：aaaabbbcccdd-gt-a4b3c3d2&quot;&gt;简单的字符串压缩：aaaabbbcccdd =&gt; a4b3c3d2&lt;/h3&gt;
&lt;pre class=&quot;prettyprint linenums lang-js&quot;&gt;let str = &#39;aaaabbbcccdd&#39;;
let strArr = str.split(&#39;&#39;);
let obj = {};
strArr.forEach(function (item) {
    if (item in obj) {
        obj[item]++;
    } else {
        obj[item] = 1;
    }
});

let sb = &#39;&#39;;
for (let key in obj) {
    sb = `${sb}${key}${obj[key]}`;
}
console.log(&#39;sb=&gt;&#39;, sb);//a4b3c3d2
&lt;/pre&gt;
&lt;h3 id=&quot;实现把数组里的值排成最大值：[3-45-67-90-22-101]-gt-906745322101&quot;&gt;实现把数组里的值排成最大值：[3, 45, 67, 90, 22, 101] =&gt; 906745322101&lt;/h3&gt;
&lt;pre class=&quot;prettyprint linenums lang-js&quot;&gt;let arr = [3, 45, 67, 90, 22, 101];

function desc(item1, item2) {
  let item1Arr = item1.toString().split(&#39;&#39;);
  let item2Arr = item2.toString().split(&#39;&#39;);
  return compare(item1Arr, item2Arr);
}

function compare(arr1, arr2) {
  let length = arr1.length &lt; arr2.length ? arr1.length : arr2.length;
  for (let x = 0; x &lt; length; x++) {
    if (arr1[x] &gt; arr2[x]) {
      return -1;
    } else if (arr1[x] &lt; arr2[x]) {
      return 1;
    } else {
      if (x == (length - 1)) {
        return 0;
      }
     continue;
    }
  }
}
arr.sort(desc);
&lt;/pre&gt;
</description>
        </item>
        
        <item>
            <title>Node.js 内存泄漏</title>
            <link>Homepage link/articles/node-memoryleak.html?utm_source=rss&amp;utm_medium=rss&amp;utm_campaign=rss</link>
            <guid>Homepage link/articles/node-memoryleak.html</guid>
            <author>chl01003698@126.com chuhongliang</author>
            <pubDate>Mon, 30 Mar 2020 00:00:00 +0800</pubDate>
            <description>&lt;h1 id=&quot;内存泄漏&quot;&gt;内存泄漏&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;Node对内存泄漏十分敏感，一旦线上应用流量千万级别，哪怕一个字节的内存泄漏也会造成堆积，垃圾回收过程中将会耗费更多时间进行对象描述，应用响应缓慢，直到进程内存溢出，应用崩溃。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;在v8的垃圾回收机制下，在通常的代码编写中，很少会出现内存泄漏的情况。但是内存泄漏通常产生于无意间，较难排查。尽管内存泄漏的情况不尽相同，但其实质只有一个，那就是应当回收的对象出现意外而没有被回收，变成了常驻在老生代中的对象。通常，造成内存泄漏的原因有如下几个。&quot;&gt;在V8的垃圾回收机制下，在通常的代码编写中，很少会出现内存泄漏的情况。但是内存泄漏通常产生于无意间，较难排查。尽管内存泄漏的情况不尽相同，但其实质只有一个，那就是应当回收的对象出现意外而没有被回收，变成了常驻在老生代中的对象。通常，造成内存泄漏的原因有如下几个。&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;缓存；&lt;/li&gt;
&lt;li&gt;队列消费不及时；&lt;/li&gt;
&lt;li&gt;作用域未释放。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;慎将内存当作缓存&quot;&gt;慎将内存当作缓存&lt;/h2&gt;
&lt;p&gt;缓存访问效率要比I/O的效率高，一旦命中缓存，就可以节省一次I/O的时间。在Node中，一个对象被当作缓存使用时，将会常驻在老生代中。缓存中存储的键越多，长期存活的对象也就越多，这将导致垃圾回收在进行扫描和整理时，对这些对象无法回收。&lt;/p&gt;
&lt;p&gt;另一个问题，js开发者喜欢用对象的键值对来缓存东西，这与严格意义上的缓存有区别，严格意义的缓存有完善的过期策略，而普通对象的键值对没有。&lt;/p&gt;
&lt;p&gt;下面代码虽然利用JS对象创建一个缓存对象，但是受垃圾回收机制的影响，只能小量使用：&lt;/p&gt;
&lt;pre class=&quot;prettyprint linenums lang-js&quot;&gt;var cache = {};
var get = function(key) {
  if (cache[key]) {
    return cache[key];
  } else {
    // get from otherwise
  }
};
var set = function (key, value) {
  cache[key] = value;
};
&lt;/pre&gt;
&lt;p&gt;上述示例，只要限定缓存对象的大小，加上完善的过期策略以防止内存无限制增长，可以用。&lt;/p&gt;
&lt;p&gt;以下是一个可能无意识造成内存泄漏的场景：memoize。underscore对memoize的实现：&lt;/p&gt;
&lt;pre class=&quot;prettyprint linenums lang-js&quot;&gt;_.memoize = function(func, hasher) {
  var memo = {};
  hasher || (hasher = _.identity);
  return function() {
    var key = hasher.apply(this, arguments);
    return _.has(memo, key) ? memo[key] : (memo[key] = func.apply(this, arguments));
  };
};
&lt;/pre&gt;
&lt;p&gt;它的原理是以参数作为键进行缓存，以内存空间换CPU执行时间。这里潜藏的陷阱即是每个被执行的结果都会按参数缓存在memo对象上，不会被清除。这在前端网页这种短时应用场景中不存在大问题，但是执行量大和参数多样性的情况下，会造成内存占用不释放。&lt;/p&gt;
&lt;p&gt;所以在Node中，任何试图拿内存当缓存的行为要小心使用。&lt;/p&gt;
&lt;h3 id=&quot;缓存限制策略&quot;&gt;缓存限制策略&lt;/h3&gt;
&lt;p&gt;为了解决缓存中的对象永远无法释放的问题，需要加入一种策略来限制缓存的无限增长。可以自己编写一个模块实现对键值对数量的限制，示例代码：&lt;/p&gt;
&lt;pre class=&quot;prettyprint linenums lang-js&quot;&gt;var LimitableMap = function(limit) {
  this.limit = limit || 10;
  this.map = {};
  this.keys = [];
};
var hasOwnProperty = Object.prototype.hasOwnProperty;
LimitableMap.prototype.set = function(key, value) {
  var map = this.map;
  var keys = this.keys;
  if (!hasOwnProperty.call(map, key)) {
    if (keys.length === this.limit) {
      var firstKey = keys.shift();
      delete map[firstKey];
    }
    keys.push(key);
  }
  map[key] = value;
};
LimitableMap.prototype.get = function (key) {
  return this.map[key];
};
&lt;/pre&gt;
&lt;p&gt;记录键在数组中，一旦超过数量，就以先进先出的方式进行淘汰。 这种淘汰策略并不是十分高效，只能应付小型应用场景。如果需要更高效的缓存，可以采用LRU算法的缓存，有限制的缓存，memoize还是可用。&lt;/p&gt;
&lt;p&gt;为了加速模块的引入，所有模块都会通过编译执行，然后被缓存起来。通过exports导出的函数，可以访问文件模块中的私有变量，这样每个文件模块在编译执行后形成的作用域因为模块缓存的原因，不会被释放。示例代码：&lt;/p&gt;
&lt;pre class=&quot;prettyprint linenums lang-js&quot;&gt;(function(exports, require, module, __filename, __dirname) {
  var local = &quot;局部变量&quot;;
  exports.get = function() {
    return local;
  };
});
&lt;/pre&gt;
&lt;p&gt;由于模块的缓存机制，模块是常驻老生代的，在设计模块时，要十分小心内存泄漏的出现，在下面的代码，每次调用leak()方法时，都导致局部变量leakArray不停增加内存的占用，且不被释放：&lt;/p&gt;
&lt;pre class=&quot;prettyprint linenums lang-js&quot;&gt;var leakArray = [];
exports.leak = function() {
  leakArray.push(&quot;leak&quot; + Math.random());
};
&lt;/pre&gt;
&lt;p&gt;如果模块需要这么设计，那么请添加清空队列的相应接口，供调用者释放内存。&lt;/p&gt;
&lt;h3 id=&quot;缓存解决方案&quot;&gt;缓存解决方案&lt;/h3&gt;
&lt;p&gt;直接将内存作为缓存方案要十分谨慎，除了限制缓存的大小，另外要考虑的是，进程之间无法共享内存。如果在进程内使用缓存，这些缓存不可避免地有重复，对物理内存的使用是一种浪费。&lt;/p&gt;
&lt;p&gt;如果使用大量缓存，目前比较好的解决方案是采用进程外的缓存，进程自身不存储状态。外部的缓存软件有良好的缓存过期淘汰策略以及自有的内存管理，不影响Node进程的性能，在Node中主要可以解决一下两个问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;将缓存转移到外部，减少常驻内存的对象的数量，让垃圾回收更高效；&lt;/li&gt;
&lt;li&gt;进程之间可以共享缓存。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;目前，市面上比较好的缓存有Redis和Memcached。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Redis：&lt;a href=&quot;https://github.com/mranney/node_redis。&quot;&gt;https://github.com/mranney/node_redis。&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Memcached：&lt;a href=&quot;https://github.com/3rd-Eden/node-memcached。&quot;&gt;https://github.com/3rd-Eden/node-memcached。&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;关注队列状态&quot;&gt;关注队列状态&lt;/h2&gt;
&lt;p&gt;内存泄漏的另一个情况则是队列。在js中可以通过队列（数组对象）来完成许多特殊的需求，比如Bagpipe。队列在消费者-生产者模型中经常充当中间产物。在大多数应用场景下，消费的速度远大于生产的速度，内存泄漏不易产生，但是一旦消费速度低于生产速度，将会形成堆积。&lt;/p&gt;
&lt;p&gt;举个例子，有的应用会收集日志。如果欠缺考虑，也许会采用数据库来记录日志。日志通常会是海量的，数据库构建在文件系统之上，写入效率远远低于文件直接写入，于是会形成数据库写入操作的堆积，而js相关作用域也不会得到释放，内存占用不会回落，从而出现内存泄漏。&lt;/p&gt;
&lt;p&gt;遇到这种场景，表层解决方案是换用消费速度更高的技术。在日志收集的案例中，换用文件写入日志的方式会更高效。需要注意的是，如果生产速度因为某些原因突然激增，或者消费速度因为突然的系统故障降低，内存泄漏还是可能出现的。&lt;/p&gt;
&lt;p&gt;深度的解决方案应该是监控队列的长度，一旦堆积，应当通过监控系统产生报警并通知相关人员。另一个解决方案是任意异步调用都应该包含超时机制，一旦在限定的时间内未完成响应，通过回调函数传递超时异常，使得任意异步调用的回调都具备可控的响应时间，给消费速度一个下限值。&lt;/p&gt;
&lt;p&gt;对于Bagpipe而言，它提供了超时模式和拒绝模式。启用超时模式时，调用加入到队列中就开始计时，超时就直接响应一个超时错误。启用拒绝模式时，当队列拥塞时，新到来的调用会直接响应拥塞错误。这两种模式都能够有效地防止队列拥塞导致的内存泄漏问题。&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&quot;内存泄漏排查&quot;&gt;内存泄漏排查&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;在Node中，由于V8的堆内存大小的限制，它对内存泄漏非常敏感。当在线服务的请求量变大时，哪怕是一个字节的泄漏都会导致内存占用过高。下面介绍一下遇到内存泄漏时的排查方案。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;有一些常见的工具来定位node应用的内存泄漏&quot;&gt;有一些常见的工具来定位Node应用的内存泄漏&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;v8-profiler：它可以用于对V8堆内存抓取快照和对CPU进行分析；&lt;/li&gt;
&lt;li&gt;node-heapdump：它允许对V8堆内存抓取快照，用于事后分析；&lt;/li&gt;
&lt;li&gt;node-mtrace：它使用GCC的mtrace工具来分析堆的使用；&lt;/li&gt;
&lt;li&gt;dtrace：有完善的dtrace工具用来分析内存泄漏；&lt;/li&gt;
&lt;li&gt;node-memwatch：来自Mozilla贡献的模块，采用WTFPL许可发布。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;node-heapdump&quot;&gt;node-heapdump&lt;/h2&gt;
&lt;p&gt;想要了解node-heapdump对内存泄漏进行排查的方式，需要先构造如下一份包含内存泄漏的代码示例，并将其存为server.js文件：&lt;/p&gt;
&lt;pre class=&quot;prettyprint linenums lang-js&quot;&gt;var leakArray = [];
var leak = function() {
  leakArray.push(&quot;leak&quot; + Math.random());
};
http.createServer(function (req, res) {
  leak();
  res.writeHead(200, {&#39;Content-Type&#39;: &#39;text/plain&#39;});
  res.end(&#39;Hello World\n&#39;);
}).listen(1337);
console.log(&#39;Server running at http://127.0.0.1:1337/&#39;);
&lt;/pre&gt;
&lt;p&gt;在上面这段代码中，每次访问服务进程都将引起leakArray数组中的元素增加，而且得不到回收。我们可以用curl工具输入&lt;a href=&quot;http://127.0.0.1:1337/命令来模拟用户访问。&quot;&gt;http://127.0.0.1:1337/命令来模拟用户访问。&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;安装node-heapdump&quot;&gt;安装node-heapdump&lt;/h3&gt;
&lt;pre class=&quot;prettyprint linenums lang-js&quot;&gt;npm install heapdump
&lt;/pre&gt;
&lt;h3 id=&quot;引入node-heapdump&quot;&gt;引入node-heapdump&lt;/h3&gt;
&lt;pre class=&quot;prettyprint linenums lang-js&quot;&gt;var heapdump = require(&#39;heapdump&#39;);
&lt;/pre&gt;
&lt;p&gt;引入node-heapdump后，访问多次，leakArray就会具备大量的元素。这个时候我们通过向服务进程发送SIGUSR2信号，让node-heapdump抓拍一份堆内存的快照。发送信号的命令如下：&lt;/p&gt;
&lt;pre class=&quot;prettyprint linenums lang-js&quot;&gt;kill -USR2 &lt;pid&gt;
&lt;/pre&gt;
&lt;p&gt;这份抓取的快照将会在文件目录下以heapdump-&lt;sec&gt;.&lt;usec&gt;.heapsnapshot的格式存放。这是一份较大的JSON文件，需要通过chrome的开发者工具打开查看。&lt;/p&gt;
&lt;p&gt;在chrome的开发者工具中选中Profiles面板，右击该文件后，从弹出的快捷菜单中选择Load...选项，打开刚才的快照文件，就可以查看堆内存中的详细信息。&lt;/p&gt;
&lt;h2 id=&quot;node-memwatch&quot;&gt;node-memwatch&lt;/h2&gt;
&lt;p&gt;准备一份内存泄漏代码：&lt;/p&gt;
&lt;pre class=&quot;prettyprint linenums lang-js&quot;&gt;var memwatch = require(&#39;memwatch&#39;);
memwatch.on(&#39;leak&#39;, function(info) {
  console.log(&#39;leak:&#39;);
  console.log(info);
});
memwatch.on(&#39;stats&#39;, function(stats) {
  console.log(&#39;stats:&#39;);
  console.log(stats);
});
var http = require(&#39;http&#39;);
var leakArray = [];
var leak = function() {
  leakArray.push(&quot;leak&quot; + Math.random());
};
http.createServer(function(req, res) {
  leak();
  res.writeHead(200, {&#39;Content-Type&#39;: &#39;text/plain&#39;});
  res.end(&#39;Hello World\n&#39;);
}).listen(1337);
console.log(&#39;Server running at http://127.0.0.1:1337/&#39;);
&lt;/pre&gt;
&lt;h2 id=&quot;stats事件&quot;&gt;stats事件&lt;/h2&gt;
&lt;p&gt;在进程中使用node-memwatch之后，每次进行全堆垃圾回收时，将会触发一次stats事件，这个事件将会传递内存的统计信息。在对上述代码创建的服务进程进行访问时，某次stats事件打印的数据如下所示，其中每项的意义卸载注释中：&lt;/p&gt;
&lt;pre class=&quot;prettyprint linenums lang-js&quot;&gt;stats:{
  num_full_gc: 4, // 第几次全堆垃圾回收
  num_inc_gc: 23, // 第几次增量垃圾回收
  heap_compactions: 4, // 第几次对老生代进行整理
  usage_trend: 0, // 使用趋势
  estimated_base: 7152944, // 预估基数
  current_base: 7152944, // 当前基数
  min: 6720776, // 最小
  max: 7152944 // 最大
}
&lt;/pre&gt;
&lt;p&gt;在这些数据中，num_full_gc和num_inc_gc比较直观地反应了垃圾回收的情况。&lt;/p&gt;
&lt;h2 id=&quot;leak事件&quot;&gt;leak事件&lt;/h2&gt;
&lt;p&gt;如果经过连续5次垃圾回收后，内存仍然没有被释放，这意味着有内存泄漏的产生，node-memwatch会触发一个leak事件。某次leak事件得到的数据如下所示：&lt;/p&gt;
&lt;pre class=&quot;prettyprint linenums lang-js&quot;&gt;  leak:{
  start: Mon Oct 07 2013 13:46:27 GMT+0800 (CST),
  end: Mon Oct 07 2013 13:54:40 GMT+0800 (CST),
  growth: 6222576,
  reason: &#39;heap growth over 5 consecutive GCs (8m 13s) - 43.33 mb/hr&#39;
}
&lt;/pre&gt;
&lt;p&gt;这个数据能显示5次垃圾回收的过程中内存增长了多少。&lt;/p&gt;
&lt;h2 id=&quot;堆内存比较&quot;&gt;堆内存比较&lt;/h2&gt;
&lt;p&gt;最终得到的leak事件的信息只能告知我们应用中存在内存泄漏，具体问题产生在何处还需要从V8的堆内存上定位。node-memwatch提供了抓取快照和比较快照的功能，它能够比较堆上对象的名称和分配数量，从而找到导致内存泄漏的元凶。&lt;/p&gt;
&lt;p&gt;下面为一段导致内存泄漏的代码，这是通过node-memwatch获取堆内存差异结果的示例：&lt;/p&gt;
&lt;pre class=&quot;prettyprint linenums lang-js&quot;&gt;var memwatch = require(&#39;memwatch&#39;);
var leakArray = [];
var leak = function() {
  leakArray.push(&quot;leak&quot; + Math.random());
};

// Take first snapshot
var hd = new memwatch.HeapDiff();

for (var i = 0; i &lt; 10000; i++) {
  leak();
}

// Take the second snapshot and compute the diff
var diff = hd.end();
console.log(JSON.stringify(diff, null, 2));
&lt;/pre&gt;
&lt;p&gt;执行node diff.js，得到的输出结果如下所示：&lt;/p&gt;
&lt;pre class=&quot;prettyprint linenums lang-js&quot;&gt;{
    &quot;before&quot;: {
        &quot;nodes&quot;: 11719,
        &quot;time&quot;: &quot;2013-10-07T06:32:07.000Z&quot;,
        &quot;size_bytes&quot;: 1493304,
        &quot;size&quot;: &quot;1.42 mb&quot;
    },
    &quot;after&quot;: {
        &quot;nodes&quot;: 31618,
        &quot;time&quot;: &quot;2013-10-07T06:32:07.000Z&quot;,
        &quot;size_bytes&quot;: 2684864,
        &quot;size&quot;: &quot;2.56 mb&quot;
    },
    &quot;change&quot;: {
        &quot;size_bytes&quot;: 1191560,
        &quot;size&quot;: &quot;1.14 mb&quot;,
        &quot;freed_nodes&quot;: 129,
        &quot;allocated_nodes&quot;: 20028,
        &quot;details&quot;: [{
                &quot;what&quot;: &quot;Array&quot;,
                &quot;size_bytes&quot;: 323720,
                &quot;size&quot;: &quot;316.13 kb&quot;,
                &quot;+&quot;: 15,
                &quot;-&quot;: 65
            },
            {
                &quot;what&quot;: &quot;Code&quot;,
                &quot;size_bytes&quot;: -10944,
                &quot;size&quot;: &quot;-10.69 kb&quot;,
                &quot;+&quot;: 8,
                &quot;-&quot;: 28
            },
            {
                &quot;what&quot;: &quot;String&quot;,
                &quot;size_bytes&quot;: 879424,
                &quot;size&quot;: &quot;858.81 kb&quot;,
                &quot;+&quot;: 20001,
                &quot;-&quot;: 1
            }
        ]
    }
}
&lt;/pre&gt;
&lt;p&gt;在上面的输出结果中，主要关注change节点下的freed_nodes和allocated_nodes，他们记录了释放的，它们记录了释放的节点数量和分配的节点数量。这里由于有内存泄漏，分配的节点数量远远多于释放的节点数量。在details下可以看到具体每种类型的分配和释放数量，主要问题展现在下面这段输出中：&lt;/p&gt;
&lt;pre class=&quot;prettyprint linenums lang-js&quot;&gt;{
    &quot;what&quot;: &quot;String&quot;,
    &quot;size_bytes&quot;: 879424,
    &quot;size&quot;: &quot;858.51 kb&quot;,
    &quot;+&quot;: 20001,
    &quot;-&quot;: 1
}
&lt;/pre&gt;
&lt;p&gt;在上述代码中，加号和减号分别表示分配和释放的字符串对象数量。可以通过上面的输出结果猜测到，有大量的字符串没有被回收。&lt;/p&gt;
&lt;h3 id=&quot;排查内存泄漏的原因主要通过对堆内存进行分析而找到。node-heapdump和node-memwatch各有所长。&quot;&gt;排查内存泄漏的原因主要通过对堆内存进行分析而找到。node-heapdump和node-memwatch各有所长。&lt;/h3&gt;
&lt;h1 id=&quot;大内存应用&quot;&gt;大内存应用&lt;/h1&gt;
&lt;p&gt;在Node中，不可避免地还是会存在操作大文件的场景。由于Node的内存限制，不过Node提供了stream模块用于处理大文件。&lt;/p&gt;
&lt;h3 id=&quot;stream模块是node的原生模块，直接引用即可。stream继承自eventemitter，具备基本的自定义事件功能，同时抽象出标准的事件和方法。它分可读和可写两种。node中的大多数模块都有stream的应用，比如fs的createreadstream-和createwritestream-方法可以分别用于创建文件的可读流与可写流，process模块中的stdin和stdout则分别是可读流和可写流的示例。&quot;&gt;stream模块是Node的原生模块，直接引用即可。stream继承自EventEmitter，具备基本的自定义事件功能，同时抽象出标准的事件和方法。它分可读和可写两种。Node中的大多数模块都有stream的应用，比如fs的createReadStream()和createWriteStream()方法可以分别用于创建文件的可读流与可写流，process模块中的stdin和stdout则分别是可读流和可写流的示例。&lt;/h3&gt;
&lt;h3 id=&quot;由于v8的内存限制，我们无法通过fsreadfile-和fswritefile-直接进行大文件的操作，而改用fscreatereadstream-和fscreatewritestream-方法通过流的方式实现对大文件的操作。&quot;&gt;由于V8的内存限制，我们无法通过fs.readFile()和fs.writeFile()直接进行大文件的操作，而改用fs.createReadStream()和fs.createWriteStream()方法通过流的方式实现对大文件的操作。&lt;/h3&gt;
&lt;p&gt;下面的代码展示了如何读取一个文件，然后将数据写入到另一个文件的过程：&lt;/p&gt;
&lt;pre class=&quot;prettyprint linenums lang-js&quot;&gt;var reader = fs.createReadStream(&#39;in.txt&#39;);
var writer = fs.createWriteStream(&#39;out.txt&#39;);
reader.on(&#39;data&#39;, function (chunk) {
  writer.write(chunk);
});
reader.on(&#39;end&#39;, function () {
  writer.end();
});
&lt;/pre&gt;
&lt;p&gt;可读流提供了管道方法pipe()，封装了data事件和写入操作。通过流的方式，上述代码不会受到V8内存限制的影响，有效地提高了程序的健壮性。&lt;/p&gt;
&lt;p&gt;如果不需要进行字符串层面的操作，则不需要借助V8来处理，可以尝试进行纯粹的Buffer操作，这不会受到V8堆内存的限制。但是这种大片使用内存的情况依然要小心，即使V8不限制堆内存的大小，物理内存依然有限制。&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>Node.js 内存控制</title>
            <link>Homepage link/articles/node-memory.html?utm_source=rss&amp;utm_medium=rss&amp;utm_campaign=rss</link>
            <guid>Homepage link/articles/node-memory.html</guid>
            <author>chl01003698@126.com chuhongliang</author>
            <pubDate>Mon, 30 Mar 2020 00:00:00 +0800</pubDate>
            <description>&lt;h1 id=&quot;高效使用内存&quot;&gt;高效使用内存&lt;/h1&gt;
&lt;p&gt;如何触发垃圾回收，第一个要介绍的是作用域（scope）。在js中能形成作用域的有函数调用、with以及全局作用域。&lt;/p&gt;
&lt;pre class=&quot;prettyprint linenums lang-js&quot;&gt;var foo = function() {
    var local = {};
};
&lt;/pre&gt;
&lt;p&gt;foo()函数在每次被调用时会创建对应的作用域，函数执行结束后，该作用域将会销毁。同时作用域中声明的局部变量分配在该作用域上，随作用域的销毁而销毁。只被局部变量引用的对象存活周期较短。在这个示例中，由于对象非常小，将会分配在新生代中的From空间中。在作用域释放后，局部变量local失效，其引用的对象将会在下次垃圾回收时被释放。&lt;/p&gt;
&lt;h3 id=&quot;以上是最基本的内存回收过程。&quot;&gt;以上是最基本的内存回收过程。&lt;/h3&gt;
&lt;h2 id=&quot;标识符查找&quot;&gt;标识符查找&lt;/h2&gt;
&lt;p&gt;与作用域相关的即是标识符查找。所谓标识符，可以理解为变量名。在下面的代码中，执行bar()函数时，将会遇到local变量：&lt;/p&gt;
&lt;pre class=&quot;prettyprint linenums lang-js&quot;&gt;var bar = function() {
  console.log(local);
};
&lt;/pre&gt;
&lt;p&gt;js在执行时会去查找该变量定义在哪里。它最先查找的是当前作用域，如果在当前作用域中无法找到该变量的声明，将会向上级的作用域里查找，直到查到为止。&lt;/p&gt;
&lt;h2 id=&quot;作用域链&quot;&gt;作用域链&lt;/h2&gt;
&lt;pre class=&quot;prettyprint linenums lang-js&quot;&gt;var foo = function() {
  var local = &#39;local var&#39;;
  var bar = function() {
    var local = &#39;another var&#39;;
    var baz = function() {
      console.log(local);
    };
    baz();
  };
  bar();
};
foo();
&lt;/pre&gt;
&lt;p&gt;local变量在baz()函数形成的作用域里查找不到，继而将在bar()的作用域里寻找。如果去掉上述代码bar()中的local声明，将会继续向上查找，一直到全局作用域。这样的查找方式使得作用域像一个链条。由于标识符的查找方向是向上的，所以变量只能向外访问，而不能向内访问。如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../assets/vendor/function_scope.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;当我们在baz()函数中访问local变量时，由于作用域中的变量列表中没有local，所以会向上一个作用域中查找，接着会在bar()函数执行得到的变量列表中找到了一个local变量的定义，于是使用它。尽管在上一层的作用域中也存在local的定义，但是不会继续查找了。如果查找一个不存在的变量，将会一直沿着作用域链查找到全局作用域，最后抛出未定义错误。&lt;/p&gt;
&lt;h2 id=&quot;变量的主动释放&quot;&gt;变量的主动释放&lt;/h2&gt;
&lt;p&gt;如果变量是全局变量（不通过var声明或定义在global变量上），由于全局作用域需要直到进程退出才能释放，此时将导致引用的对象常驻内存（常驻在老生代中）。如果需要释放常驻内存的对象，可以通过delete操作来删除引用关系。或者将变量重新赋值，让旧的对象脱离引用关系。举个示例，老生代内存清除和整理的过程中，会被回收释放&lt;/p&gt;
&lt;pre class=&quot;prettyprint linenums lang-js&quot;&gt;global.foo = &quot;I am global object&quot;;
console.log(global.foo); // =&gt; &quot;I am global object&quot;
delete global.foo;
// 或者重新赋值
global.foo = undefined; // or null
console.log(global.foo); // =&gt; undefined
&lt;/pre&gt;
&lt;h3 id=&quot;同样，如果在非全局作用域中，想主动释放变量引用的对象，也可以通过这样的方式。虽然delete操作和重新赋值具有相同的效果，但是在v8中通过delete删除对象的属性有可能干扰v8的优化，所以通过赋值方式解除引用更好。&quot;&gt;同样，如果在非全局作用域中，想主动释放变量引用的对象，也可以通过这样的方式。虽然delete操作和重新赋值具有相同的效果，但是在V8中通过delete删除对象的属性有可能干扰V8的优化，所以通过赋值方式解除引用更好。&lt;/h3&gt;
&lt;h2 id=&quot;闭包&quot;&gt;闭包&lt;/h2&gt;
&lt;p&gt;下面代码，local会得到未定义的异常：&lt;/p&gt;
&lt;pre class=&quot;prettyprint linenums lang-js&quot;&gt;var foo = function() {
  (function() {
    var local = &quot;局部变量&quot;;
  }());
  console.log(local);
};
&lt;/pre&gt;
&lt;p&gt;在js中，实现外部作用域访问内部作用域中变量的方法叫做闭包（closure）。这得益于高阶函数的特性：函数可以作为参数或者返回值。&lt;/p&gt;
&lt;pre class=&quot;prettyprint linenums lang-js&quot;&gt;var foo = function() {
  var bar = function() {
    var local = &quot;局部变量&quot;;
    return function() {
      return local;
    };
  };
  var baz = bar();
  console.log(baz());
};
&lt;/pre&gt;
&lt;h3 id=&quot;在bar-函数执行完成后，局部变量local将会随着作用域的销毁而被回收。但是注意这里的特点在于返回值是一个匿名函数，且这个函数中具备了访问local的条件。虽然在后续的执行中，在外部作用域中还是无法直接访问local，但是若要访问它，可以通过中间函数来过渡。&quot;&gt;在bar()函数执行完成后，局部变量local将会随着作用域的销毁而被回收。但是注意这里的特点在于返回值是一个匿名函数，且这个函数中具备了访问local的条件。虽然在后续的执行中，在外部作用域中还是无法直接访问local，但是若要访问它，可以通过中间函数来过渡。&lt;/h3&gt;
&lt;h3 id=&quot;闭包是js的高级特性，利用它可以产生很多巧妙的效果。它的问题在于，一旦有变量引用这个中间函数，这个中间函数将不会释放，同时也会使原始的作用域得不到释放，作用域中产生的内存占用也不会得到释放。除非不再有引用，才会逐步释放。&quot;&gt;闭包是js的高级特性，利用它可以产生很多巧妙的效果。它的问题在于，一旦有变量引用这个中间函数，这个中间函数将不会释放，同时也会使原始的作用域得不到释放，作用域中产生的内存占用也不会得到释放。除非不再有引用，才会逐步释放。&lt;/h3&gt;
&lt;h3 id=&quot;在正常js执行中，无法立即回收的内存有闭包和全局变量引用这两种情况。由于v8的内存限制，要十分小心此类变量是否无限制地增加，因为它会导致老生代中的对象增多。&quot;&gt;在正常js执行中，无法立即回收的内存有闭包和全局变量引用这两种情况。由于V8的内存限制，要十分小心此类变量是否无限制地增加，因为它会导致老生代中的对象增多。&lt;/h3&gt;
&lt;hr&gt;
&lt;h1 id=&quot;内存指标&quot;&gt;内存指标&lt;/h1&gt;
&lt;h2 id=&quot;查看内存使用情况&quot;&gt;查看内存使用情况&lt;/h2&gt;
&lt;p&gt;前面用到的process.memoryUsage()可以查看内存使用情况。除此之外，os模块中totalmem()和freemem()方法也可以查看内存使用情况。&lt;/p&gt;
&lt;h3 id=&quot;查看进程的内存占用&quot;&gt;查看进程的内存占用&lt;/h3&gt;
&lt;p&gt;调用process.memoryUsage()可以看到Node进程的内存占用情况，示例代码如下：&lt;/p&gt;
&lt;pre class=&quot;prettyprint linenums lang-js&quot;&gt;`$` node
`&gt;` process.memoryUsage()
{
  rss: 18821120,
  heapTotal: 10295296,
  heapUsed: 5013664
}
&lt;/pre&gt;
&lt;h3 id=&quot;rss是resident-set-size的缩写，即进程的常驻内存部分。进程的内存总共有几部分，一部分是rss，其余部分在交换区（swap）或者文件系统（filesystem）中。&quot;&gt;rss是resident set size的缩写，即进程的常驻内存部分。进程的内存总共有几部分，一部分是rss，其余部分在交换区（swap）或者文件系统（filesystem）中。&lt;/h3&gt;
&lt;h3 id=&quot;除了rss外，heaptotal和heapused对应的是v8的堆内存信息。heaptotal是堆中总共申请的内存量，heapused表示目前堆中使用中的内存量。这3个值的单位都是字节。为了更好地查看效果，我们格式化一下输出结果：&quot;&gt;除了rss外，heapTotal和heapUsed对应的是V8的堆内存信息。heapTotal是堆中总共申请的内存量，heapUsed表示目前堆中使用中的内存量。这3个值的单位都是字节。为了更好地查看效果，我们格式化一下输出结果：&lt;/h3&gt;
&lt;pre class=&quot;prettyprint linenums lang-js&quot;&gt;var showMem = function() {
  var mem = process.memoryUsage();
  var format = function(bytes) {
    return (bytes / 1024 / 1024).toFixed(2) + &#39; MB&#39;;
  };
  console.log(&#39;Process: heapTotal &#39; + format(mem.heapTotal) + &#39; heapUsed &#39; + format(mem.heapUsed) + &#39; rss &#39; + format(mem.rss));
  console.log(&#39;---------------------------------------------------------------------------&#39;);
};
&lt;/pre&gt;
&lt;p&gt;同时，写一个方法用于不停地分配内存但不释放内存，相关代码如下：&lt;/p&gt;
&lt;pre class=&quot;prettyprint linenums lang-js&quot;&gt;var useMem = function() {
  var size = 20 * 1024 * 1024;
  var arr = new Array(size);
  for (var i = 0; i &lt; size; i++) {
    arr[i] = 0;
  }
  return arr;
};
var total = [];
for (var j = 0; j &lt; 15; j++) {
  showMem();
  total.push(useMem());
}
showMem();
&lt;/pre&gt;
&lt;p&gt;将以上代码存为outofmemory.js并执行它，得到的输出结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../assets/vendor/outofmemory.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;可以看到，每次调用useMem都导致了3个值的增长。在接近1500MB的时候，无法继续分配内存，然后进程内存溢出了，连循环体都无法执行完成，仅执行了9次。&lt;/p&gt;
&lt;h3 id=&quot;查看系统的内存占用&quot;&gt;查看系统的内存占用&lt;/h3&gt;
&lt;p&gt;与process.memoryUsage()不同的是，os模块中的totalmem()和freemem()这两个方法用于查看操作系统的内存使用情况，它们分别返回系统的总内存和闲置内存，以字节为单位。示例代码如下：&lt;/p&gt;
&lt;pre class=&quot;prettyprint linenums lang-txt&quot;&gt;`$` node
`&gt;` os.totalmem()
`&gt;` 12798062592
`&gt;` os.freemem()
`&gt;` 2753875968
&lt;/pre&gt;
&lt;h3 id=&quot;从输出信息看，这台电脑总内存为8gb，当前闲置内存大致为42gb。&quot;&gt;从输出信息看，这台电脑总内存为8GB，当前闲置内存大致为4.2GB。&lt;/h3&gt;
&lt;h2 id=&quot;堆外内存&quot;&gt;堆外内存&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;通过process.memoryUsage()的结果可以看到，堆中的内存用量总是小于进程的常驻内存用量。这意味着Node中的内存使用并非都是通过V8进行分配的。我们将那些不是通过V8分配的内存称为堆外内存。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这里将前面的useMem()方法稍微改造一下，将Array变为Buffer，将size变大，每一次构造200MB的对象，相关代码如下：&lt;/p&gt;
&lt;pre class=&quot;prettyprint linenums lang-js&quot;&gt;var useMem = function() {
  var size = 200 * 1024 * 1024;
  var buffer = new Buffer(size);
  for (var i = 0; i &lt; size; i++) {
    buffer[i] = 0;
  }
  return buffer;
};
&lt;/pre&gt;
&lt;p&gt;重新执行该代码，得到的输出结果如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../assets/vendor/out_of_buffer.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;15次循环都完整执行，并且三个内存占用值与前一个示例完全不同。在改造后的输出结果中，heaptotal和heapused的变化极小，唯一变化的是rss的值，并且该值已经远远超过v8的限制值。这其中的原因是buffer对象不同于其他对象，它不经过v8的内存分配机制，所以也不会有堆内存的大小限制。&quot;&gt;15次循环都完整执行，并且三个内存占用值与前一个示例完全不同。在改造后的输出结果中，heapTotal和heapUsed的变化极小，唯一变化的是rss的值，并且该值已经远远超过V8的限制值。这其中的原因是Buffer对象不同于其他对象，它不经过V8的内存分配机制，所以也不会有堆内存的大小限制。&lt;/h3&gt;
&lt;h3 id=&quot;这意味着利用堆外内存可以突破内存限制的问题。&quot;&gt;这意味着利用堆外内存可以突破内存限制的问题。&lt;/h3&gt;
&lt;h3 id=&quot;为何buffer对象并非通过v8分配？这在于node并不同于浏览器的应用场景。在浏览器中，js直接处理字符串即可满足绝大多数的业务需求，而node则需要处理网络流和文件i-o流，操作字符串远远不能满足传输的性能需求。&quot;&gt;为何Buffer对象并非通过V8分配？这在于Node并不同于浏览器的应用场景。在浏览器中，js直接处理字符串即可满足绝大多数的业务需求，而Node则需要处理网络流和文件I/O流，操作字符串远远不能满足传输的性能需求。&lt;/h3&gt;
&lt;h3 id=&quot;从上面得知，node内存构成主要由通过v8进行分配的部分和node自行分配的部分。受v8的垃圾回收限制的主要是v8的堆内存。&quot;&gt;从上面得知，Node内存构成主要由通过V8进行分配的部分和Node自行分配的部分。受V8的垃圾回收限制的主要是V8的堆内存。&lt;/h3&gt;
</description>
        </item>
        
    </channel>
</rss>
