<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0">
    <channel>
        <title>RSS feed title</title>
        <link>Homepage link</link>
        <description>RSS feed description</description>
        <lastBuildDate>Mon, 27 Apr 2020 21:53:54 +0800</lastBuildDate>
        <language>zh-cn</language>
        
        <item>
            <title>Node.js 简介</title>
            <link>Homepage link/articles/nodejs.html?utm_source=rss&amp;utm_medium=rss&amp;utm_campaign=rss</link>
            <guid>Homepage link/articles/nodejs.html</guid>
            <author>chl01003698@126.com chuhongliang</author>
            <pubDate>Sun, 26 Jan 2020 00:00:00 +0800</pubDate>
            <description>&lt;h2 id=&quot;nodejs&quot;&gt;Node.js&lt;/h2&gt;
&lt;p&gt;Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。 Node.js 使用了一个事件驱动、非阻塞式 I/O 的模型。 &lt;/p&gt;
&lt;p&gt;Node 是一个让 JavaScript 运行在服务端的开发平台，它让 JavaScript 成为与PHP、Python、Perl、Ruby 等服务端语言平起平坐的脚本语言。 发布于2009年5月，由Ryan Dahl开发，实质是对Chrome V8引擎进行了封装。&lt;/p&gt;
&lt;p&gt;Node对一些特殊用例进行优化，提供替代的API，使得V8在非浏览器环境下运行得更好。V8引擎执行Javascript的速度非常快，性能非常好。Node是一个基于Chrome JavaScript运行时建立的平台， 用于方便地搭建响应速度快、易于扩展的网络应用。Node 使用事件驱动， 非阻塞I/O 模型而得以轻量和高效，非常适合在分布式设备上运行数据密集型的实时应用。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;发展史&quot;&gt;发展史&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;2009年2月，Ryan Dahl在博客上宣布准备基于V8创建一个轻量级的Web服务器并提供一套库。&lt;/li&gt;
&lt;li&gt;2009年5月，Ryan Dahl在GitHub上发布了最初版本的部分Node包，随后几个月里，有人开始使用Node开发应用。&lt;/li&gt;
&lt;li&gt;2009年11月和2010年4月，两届JSConf大会都安排了Node.js的讲座。&lt;/li&gt;
&lt;li&gt;2010年年底，Node获得云计算服务商Joyent资助，创始人Ryan Dahl加入Joyent全职负责Node的发展。&lt;/li&gt;
&lt;li&gt;2011年7月，Node在微软的支持下发布Windows版本。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&quot;特性&quot;&gt;特性&lt;/h2&gt;
&lt;p&gt;V8引擎本身使用了一些最新的编译技术。这使得用Javascript这类脚本语言编写出来的代码运行速度获得了极大提升，又节省了开发成本。对性能的苛求是Node的一个关键因素。 Javascript是一个事件驱动语言，Node利用了这个优点，编写出可扩展性高的服务器。Node采用了一个称为“事件循环(event loop）”的架构，使得编写可扩展性高的服务器变得既容易又安全。提高服务器性能的技巧有多种多样。Node选择了一种既能提高性能，又能减低开发复杂度的架构。这是一个非常重要的特性。并发编程通常很复杂且布满地雷。Node绕过了这些，但仍提供很好的性能。
Node采用一系列“非阻塞”库来支持事件循环的方式。本质上就是为文件系统、数据库之类的资源提供接口。向文件系统发送一个请求时，无需等待硬盘（寻址并检索文件），硬盘准备好的时候非阻塞接口会通知Node。该模型以可扩展的方式简化了对慢资源的访问， 直观，易懂。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;适用场景&quot;&gt;适用场景&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Node.js适合做一些高并发的，I/O密集型的应用。&lt;/li&gt;
&lt;li&gt;当应用程序需要处理大量并发的I/O，而在向客户端发出响应之前，应用程序内部并不需要进行非常复杂的处理的时候，Node.js非常适合。Node.js也非常适合与web socket配合，开发长连接的实时交互应用程序。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&quot;nodejs优点&quot;&gt;Node.js优点&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;采用事件驱动、异步编程，为网络服务而设计。其实Javascript的匿名函数和闭包特性非常适合事件驱动、异步编程。而且JavaScript也简单易学，很多前端设计人员可以很快上手做后端设计。&lt;/li&gt;
&lt;li&gt;Node.js非阻塞模式的IO处理给Node.js带来在相对低系统资源耗用下的高性能与出众的负载能力，非常适合用作依赖其它IO资源的中间层服务。&lt;/li&gt;
&lt;li&gt;Node.js轻量高效，可以认为是数据密集型分布式部署环境下的实时应用系统的完美解决方案。Node非常适合如下情况：在响应客户端之前，您预计可能有很高的流量，但所需的服务器端逻辑和处理不一定很多。&lt;/li&gt;
&lt;li&gt;单进程，节约资源&lt;/li&gt;
&lt;li&gt;异步I/O，提升并发量&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&quot;nodejs缺点&quot;&gt;Node.js缺点&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;可靠性低, 一旦出现未捕获的异常将直接导致服务不可用.&lt;/li&gt;
&lt;li&gt;单进程，单线程，只支持单核CPU，不能充分的利用多核CPU服务器。一旦这个进程崩掉，那么整个web服务就崩掉了。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;以上缺点可以可以通过代码的健壮性来弥补。使用cluster模式开启多个进程。 设置全局异常捕获器。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        </item>
        
        <item>
            <title>Node.js 模块</title>
            <link>Homepage link/articles/node-module.html?utm_source=rss&amp;utm_medium=rss&amp;utm_campaign=rss</link>
            <guid>Homepage link/articles/node-module.html</guid>
            <author>chl01003698@126.com chuhongliang</author>
            <pubDate>Mon, 27 Jan 2020 00:00:00 +0800</pubDate>
            <description>&lt;h1 id=&quot;nodejs-模块&quot;&gt;Node.js 模块&lt;/h1&gt;
&lt;p&gt;在 Node.js 模块系统中，每个文件都被视为一个独立的模块&lt;/p&gt;
&lt;p&gt;Node.js 模块机制采用了 Commonjs 规范，弥补了当前 JavaScript 开发大型应用没有标准的缺陷，类似于 Java 中的类文件，Python 中的 import 机制，Node.js 中可以通过 module.exports、require 来导出和引入一个模块.&lt;/p&gt;
&lt;p&gt;在模块加载机制中，Node.js 采用了延迟加载的策略，只有在用到的情况下，系统模块才会被加载，加载完成后会放到 binding_cache 中。&lt;/p&gt;
&lt;h2 id=&quot;模块的分类&quot;&gt;模块的分类&lt;/h2&gt;
&lt;h3 id=&quot;系统模块&quot;&gt;系统模块&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;C/C++ 模块，也叫 built-in 内建模块，一般用于 native 模块调用，在 require 出去&lt;/li&gt;
&lt;li&gt;native 模块，在开发中使用的 Node.js 的 http、buffer、fs 等，底层也是调用的内建模块 (C/C++)。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;第三方模块&quot;&gt;第三方模块&lt;/h3&gt;
&lt;h4 id=&quot;非-nodejs-自带的模块称为第三方模块，其实还分为路径形式的文件模块（以-code-code-、-code-code-、-code-code-开头的）和自定义的模块（比如-express、koa-框架、momentjs-等）&quot;&gt;非 Node.js 自带的模块称为第三方模块，其实还分为路径形式的文件模块（以 &lt;code&gt;.&lt;/code&gt;、&lt;code&gt;..&lt;/code&gt;、&lt;code&gt;/&lt;/code&gt; 开头的）和自定义的模块（比如 express、koa 框架、moment.js 等）&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;javaScript 模块：例如 &lt;code&gt;hello.js&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;json 模块：例如 &lt;code&gt;hello.json&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;C/C++ 模块：编译之后扩展名为 .node 的模块，例如 &lt;code&gt;hello.node&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;目录结构&quot;&gt;目录结构&lt;/h3&gt;
&lt;pre class=&quot;prettyprint linenums lang-js&quot;&gt;  ├── benchmark                         一些 Node.js 性能测试代码
  ├── deps                              Node.js 依赖
  ├── doc                               文档
  ├── lib                               Node.js 对外暴露的 js 模块源码
  ├── src                               Node.js 的 c/c++ 源码文件，内建模块
  ├── test                              单元测试
  ├── tools                             编译时用到的工具
  ├── doc                               api 文档
  ├── vcbuild.bat                       win 平台 makefile 文件
  ├── node.gyp                          node-gyp 构建编译任务的配置文件               
&lt;/pre&gt;
&lt;hr&gt;
&lt;h2 id=&quot;模块加载机制&quot;&gt;模块加载机制&lt;/h2&gt;
&lt;p&gt;在 Node.js 中模块加载一般会经历 3 个步骤，&lt;code&gt;路径分析&lt;/code&gt;、&lt;code&gt;文件定位&lt;/code&gt;、&lt;code&gt;编译执行&lt;/code&gt;。&lt;/p&gt;
&lt;h4 id=&quot;按照模块的分类，按照以下顺序进行优先加载：&quot;&gt;按照模块的分类，按照以下顺序进行优先加载：&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;系统缓存&lt;/strong&gt;：模块被执行之后会会进行缓存，首先是先进行缓存加载，判断缓存中是否有值。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;系统模块&lt;/strong&gt;：也就是原生模块，这个优先级仅次于缓存加载，部分核心模块已经被编译成二进制，省略了 &lt;code&gt;路径分析&lt;/code&gt;、&lt;code&gt;文件定位&lt;/code&gt;，直接加载到了内存中，系统模块定义在 Node.js 源码的 lib 目录下，可以去查看。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;文件模块&lt;/strong&gt;：优先加载 &lt;code&gt;.&lt;/code&gt;、&lt;code&gt;..&lt;/code&gt;、&lt;code&gt;/&lt;/code&gt; 开头的，如果文件没有加上扩展名，会依次按照 &lt;code&gt;.js&lt;/code&gt;、&lt;code&gt;.json&lt;/code&gt;、&lt;code&gt;.node&lt;/code&gt; 进行扩展名补足尝试，那么&lt;strong&gt;在尝试的过程中也是以同步阻塞模式来判断文件是否存在&lt;/strong&gt;，从性能优化的角度来看待，&lt;code&gt;.json&lt;/code&gt;、&lt;code&gt;.node&lt;/code&gt;最好还是加上文件的扩展名。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;目录做为模块&lt;/strong&gt;：这种情况发生在文件模块加载过程中，也没有找到，但是发现是一个目录的情况，这个时候会将这个目录当作一个 &lt;code&gt;包&lt;/code&gt; 来处理，Node 这块采用了 Commonjs 规范，先会在项目根目录查找 package.json 文件，取出文件中定义的 main 属性 &lt;code&gt;(&quot;main&quot;: &quot;lib/hello.js&quot;)&lt;/code&gt; 描述的入口文件进行加载，也没加载到，则会抛出默认错误: Error: Cannot find module &#39;lib/hello.js&#39;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;node_modules 目录加载&lt;/strong&gt;：对于系统模块、路径文件模块都找不到，Node.js 会从当前模块的父目录进行查找，直到系统的根目录&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;模块缓存&quot;&gt;模块缓存&lt;/h2&gt;
&lt;p&gt;模块在第一次加载后会被缓存。 这也意味着（类似其他缓存机制）如果每次调用 require(&#39;foo&#39;) 都解析到同一文件，则返回相同的对象。&lt;/p&gt;
&lt;p&gt;多次调用 require(foo) 不会导致模块的代码被执行多次。 这是一个重要的特性。 借助它, 可以返回“部分完成”的对象，从而允许加载依赖的依赖, 即使它们会导致循环依赖。&lt;/p&gt;
&lt;p&gt;如果想要多次执行一个模块，可以导出一个函数，然后调用该函数。&lt;/p&gt;
&lt;p&gt;Node.js 提供了 require.cache API 查看已缓存的模块，返回值为对象.&lt;/p&gt;
&lt;h4 id=&quot;为了验证，这里做一个简单的测试，如下所示：&quot;&gt;为了验证，这里做一个简单的测试，如下所示：&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;新建 test-module.js 文件&lt;/strong&gt;
这里我导出一个变量和一个方法&lt;/p&gt;
&lt;pre class=&quot;prettyprint linenums lang-js&quot;&gt;module.exports = {
    a: 1,
    test: () =&gt; {}
}
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;新建 test.js 文件&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;prettyprint linenums lang-js&quot;&gt;require(&#39;./test-module.js&#39;);
console.log(require.cache);
&lt;/pre&gt;
&lt;p&gt;在这个文件里加载 test-module.js 文件，在之后打印下 require.cache 看下里面返回的是什么？看到以下结果应该就很清晰了，模块的文件名、地址、导出数据都很清楚。&lt;/p&gt;
&lt;h2 id=&quot;模块循环引用&quot;&gt;模块循环引用&lt;/h2&gt;
&lt;p&gt;当循环调用 require() 时，一个模块可能在未完成执行时被返回。&lt;/p&gt;
&lt;p&gt;例如以下情况:&lt;/p&gt;
&lt;p&gt;a.js:&lt;/p&gt;
&lt;pre class=&quot;prettyprint linenums lang-js&quot;&gt;console.log(&#39;a 开始&#39;);
exports.done = false;
const b = require(&#39;./b.js&#39;);
console.log(&#39;在 a 中，b.done = %j&#39;, b.done);
exports.done = true;
console.log(&#39;a 结束&#39;);
&lt;/pre&gt;
&lt;p&gt;b.js:&lt;/p&gt;
&lt;pre class=&quot;prettyprint linenums lang-js&quot;&gt;console.log(&#39;b 开始&#39;);
exports.done = false;
const a = require(&#39;./a.js&#39;);
console.log(&#39;在 b 中，a.done = %j&#39;, a.done);
exports.done = true;
console.log(&#39;b 结束&#39;);
&lt;/pre&gt;
&lt;p&gt;main.js:&lt;/p&gt;
&lt;pre class=&quot;prettyprint linenums lang-js&quot;&gt;console.log(&#39;main 开始&#39;);
const a = require(&#39;./a.js&#39;);
const b = require(&#39;./b.js&#39;);
console.log(&#39;在 main 中，a.done=%j，b.done=%j&#39;, a.done, b.done);
&lt;/pre&gt;
&lt;p&gt;当 main.js 加载 a.js 时， a.js 又加载 b.js。 此时， b.js 会尝试去加载 a.js。 为了防止无限的循环，会返回一个 a.js 的 exports 对象的 未完成的副本 给 b.js 模块。 然后 b.js 完成加载，并将 exports 对象提供给 a.js 模块。&lt;/p&gt;
&lt;p&gt;当 main.js 加载这两个模块时，它们都已经完成加载。 因此，该程序的输出会是：&lt;/p&gt;
&lt;pre class=&quot;prettyprint linenums lang-js&quot;&gt;$ node main.js
main 开始
a 开始
b 开始
在 b 中，a.done = false
b 结束
在 a 中，b.done = true
a 结束
在 main 中，a.done=true，b.done=true
&lt;/pre&gt;
</description>
        </item>
        
        <item>
            <title>JavaScript 简介</title>
            <link>Homepage link/articles/javascript.html?utm_source=rss&amp;utm_medium=rss&amp;utm_campaign=rss</link>
            <guid>Homepage link/articles/javascript.html</guid>
            <author>chl01003698@126.com chuhongliang</author>
            <pubDate>Mon, 27 Jan 2020 00:00:00 +0800</pubDate>
            <description>&lt;h3 id=&quot;javascript&quot;&gt;Javascript&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;JavaScript（简称“JS”） 是一种具有函数优先的轻量级，解释型或即时编译型的编程语言。虽然它是作为开发Web页面的脚本语言而出名的，但是它也被用到了很多非浏览器环境中，JavaScript 基于原型编程、多范式的动态脚本语言，并且支持面向对象、命令式和声明式（如函数式编程）风格。&lt;/li&gt;
&lt;li&gt;JavaScript在1995年由Netscape公司的Brendan Eich，在网景导航者浏览器上首次设计实现而成。因为Netscape与Sun合作，Netscape管理层希望它外观看起来像Java，因此取名为JavaScript。但实际上它的语法风格与Self及Scheme较为接近。&lt;/li&gt;
&lt;li&gt;JavaScript的标准是ECMAScript 。截至 2012 年，所有浏览器都完整的支持ECMAScript 5.1，旧版本的浏览器至少支持ECMAScript 3 标准。2015年6月17日，ECMA国际组织发布了ECMAScript 的第六版，该版本正式名称为 ECMAScript 2015，但通常被称为ECMAScript 6 或者ES6。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;基本特点&quot;&gt;基本特点&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;JavaScript是一种属于网络的脚本语言,已经被广泛用于Web应用开发,常用来为网页添加各式各样的动态功能,为用户提供更流畅美观的浏览效果。通常JavaScript脚本是通过嵌入在HTML中来实现自身的功能的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;是一种解释性脚本语言（代码不进行预编译）。 &lt;/li&gt;
&lt;li&gt;主要用来向HTML（标准通用标记语言下的一个应用）页面添加交互行为。 &lt;/li&gt;
&lt;li&gt;可以直接嵌入HTML页面，但写成单独的js文件有利于结构和行为的分离。 &lt;/li&gt;
&lt;li&gt;跨平台特性，在绝大多数浏览器的支持下，可以在多种平台下运行（如Windows、Linux、Mac、Android、iOS等）。&lt;/li&gt;
&lt;li&gt;Javascript脚本语言同其他语言一样，有它自身的基本数据类型，表达式和算术运算符及程序的基本程序框架。Javascript提供了四种基本的数据类型和两种特殊数据类型用来处理数据和文字。而变量提供存放信息的地方，表达式则可以完成较复杂的信息处理。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;历史&quot;&gt;历史&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;它最初由Netscape的Brendan Eich设计。JavaScript是甲骨文公司的注册商标。Ecma国际以JavaScript为基础制定了ECMAScript标准。JavaScript也可以用于其他场合，如服务器端编程。完整的JavaScript实现包含三个部分：ECMAScript，文档对象模型，浏览器对象模型。  &lt;/li&gt;
&lt;li&gt;Netscape在最初将其脚本语言命名为LiveScript，后来Netscape在与Sun合作之后将其改名为JavaScript。JavaScript最初受Java启发而开始设计的，目的之一就是“看上去像Java”，因此语法上有类似之处，一些名称和命名规范也借自Java。但JavaScript的主要设计原则源自Self和Scheme。JavaScript与Java名称上的近似，是当时Netscape为了营销考虑与Sun微系统达成协议的结果。为了取得技术优势，微软推出了JScript来迎战JavaScript的脚本语言。为了互用性，Ecma国际（前身为欧洲计算机制造商协会）创建了ECMA-262标准（ECMAScript）。两者都属于ECMAScript的实现。尽管JavaScript作为给非程序人员的脚本语言，而非作为给程序人员的脚本语言来推广和宣传，但是JavaScript具有非常丰富的特性。 &lt;/li&gt;
&lt;li&gt;发展初期，JavaScript的标准并未确定，同期有Netscape的JavaScript，微软的JScript和CEnvi的ScriptEase三足鼎立。1997年，在ECMA（欧洲计算机制造商协会）的协调下，由Netscape、Sun、微软、Borland组成的工作组确定统一标准：ECMA-262。&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        
        <item>
            <title>JavaScript 类型</title>
            <link>Homepage link/articles/javascript-type.html?utm_source=rss&amp;utm_medium=rss&amp;utm_campaign=rss</link>
            <guid>Homepage link/articles/javascript-type.html</guid>
            <author>chl01003698@126.com chuhongliang</author>
            <pubDate>Tue, 28 Jan 2020 00:00:00 +0800</pubDate>
            <description>&lt;h1 id=&quot;原始类型与引用类型&quot;&gt;原始类型与引用类型&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;JavaScript原始类型: Undefined、Null、Boolean、Number、String、Symbol &lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;JavaScript引用类型: Object &lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;原始类型-基础类型-&quot;&gt;原始类型(基础类型)&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;原始类型&lt;/strong&gt;又被称为&lt;strong&gt;基本类型&lt;/strong&gt;，原始类型保存的变量和值直接保存在&lt;strong&gt;栈内存&lt;/strong&gt;(Stack)中,且空间相互独立,通过值来访问&lt;/p&gt;
&lt;pre class=&quot;prettyprint linenums lang-js&quot;&gt;let name = &#39;jane&#39;;
let name1 = name;
console.log(name === name1);//true
name = &#39;tom&#39;;
console.log(name);//tome
console.log(name1);//jane
&lt;/pre&gt;
&lt;p&gt;可以看到name的值虽然改变，但是name1的值是独立存储的所以不受影响&lt;/p&gt;
&lt;p&gt;虽然原始类型的值是储存在相对独立空间,但是它们之间的比较是按值比较的.&lt;/p&gt;
&lt;h2 id=&quot;引用类型&quot;&gt;引用类型&lt;/h2&gt;
&lt;p&gt;引用类型,即Object 类型,再往下细分，还可以分为：Object 类型、Array 类型、Date 类型、Function 类型 等。&lt;/p&gt;
&lt;p&gt;与原始类型不同的是,引用类型的内容是保存在&lt;strong&gt;堆内存&lt;/strong&gt;中,而&lt;strong&gt;栈内存&lt;/strong&gt;(Heap)中会有一个&lt;strong&gt;堆内存地址&lt;/strong&gt;,通过这个地址变量被指向堆内存中&lt;code&gt;Object&lt;/code&gt;真正的值,因此引用类型是按照引用访问的.&lt;/p&gt;
&lt;pre class=&quot;prettyprint linenums lang-js&quot;&gt;let person1 = { name: &quot;tome&quot;, age: 20 };
let person2 = person1;
person1.name = &quot;jane&quot;;
console.log(person2.name);    // jane
person2.age = 22;
console.log(person1.age);     // 22
var person3 = {
    name: &quot;jane&quot;,
    age: 22
};
console.log(person1 === person3); //false
&lt;/pre&gt;
&lt;p&gt;person1和person2两个变量指向了同一个对象。因此，改变其中任何一个变量，都会相互影响&lt;/p&gt;
&lt;p&gt;person3是新建了一个对象, 在堆内存中确实两个相互独立的Object,引用类型是按照引用比较,由于person1和person3引用的是不同的Object所以得到的结果是fasle.&lt;/p&gt;
&lt;h2 id=&quot;类型中的坑&quot;&gt;类型中的坑&lt;/h2&gt;
&lt;h3 id=&quot;稀疏数组-指的是含有空白或空缺单元的数组&quot;&gt;稀疏数组: 指的是含有空白或空缺单元的数组&lt;/h3&gt;
&lt;pre class=&quot;prettyprint linenums lang-js&quot;&gt;let arr = [];
console.log(arr.length); //0
arr[4] = arr[5];
console.log(arr.length); //5
arr.forEach(elem =&gt; {
  console.log(elem); //undefined
});
console.log(arr); //[,,,,undefined]
&lt;/pre&gt;
&lt;h4 id=&quot;这里有几个坑需要注意-&quot;&gt;这里有几个坑需要注意:&lt;/h4&gt;
&lt;p&gt;开始建立的空数组a的长度为0,这可以理解,但是在a[4] = a[5]之后出现了问题,a的长度居然变成了5,此时a数组是[,,,,undefined]这种形态.&lt;/p&gt;
&lt;p&gt;我们通过遍历,只得到了undefined这一个值,这个undefind是由于a[4] = a[5]赋值,由于a[5]没有定义值为undefined被赋给了a[4],可以等价为a[4] = undefined.&lt;/p&gt;
&lt;h3 id=&quot;字符串索引&quot;&gt;字符串索引&lt;/h3&gt;
&lt;pre class=&quot;prettyprint linenums lang-js&quot;&gt;let a = [];
a[0] = 1;
a[&#39;name&#39;] = &#39;tom&#39;;
console.log(a.length); //1
console.log(a[&#39;name&#39;]); //tom
console.log(a); //[ 1, name: &#39;tom&#39; ]
&lt;/pre&gt;
&lt;p&gt;数组不仅可以通过数字索引,也可以通过字符串索引,但值得注意的是,字符串索引的键值对并不算在数组的长度里.&lt;/p&gt;
&lt;h3 id=&quot;数字中的坑-二进制浮点数&quot;&gt;数字中的坑 二进制浮点数&lt;/h3&gt;
&lt;p&gt;JavaScript 中的数字类型是基于“二进制浮点数”实现的,使用的是“双精度”格式,这就带来了一些反常的问题,我们那一道经典面试提来讲解下.&lt;/p&gt;
&lt;pre class=&quot;prettyprint linenums lang-js&quot;&gt;let a = 0.1 + 0.2;
let b = 0.3;
console.log(a === b); //false
&lt;/pre&gt;
&lt;p&gt;这是个出人意料的结果,实际上a的值约为0.30000000000000004这并不是一个整数值,这就是二进制浮点数带来的副作用.&lt;/p&gt;
&lt;pre class=&quot;prettyprint linenums lang-js&quot;&gt;let a = 0.1 + 0.2;
let b = 0.3;
console.log(a === b); //false
console.log(Number.isInteger(a*10)); //false
console.log(Number.isInteger(b*10)); //true
console.log(a); //0.30000000000000004
&lt;/pre&gt;
&lt;p&gt;我们可以用Number.isInteger()来判断一个数字是否为整数.&lt;/p&gt;
&lt;h3 id=&quot;nan&quot;&gt;NaN&lt;/h3&gt;
&lt;pre class=&quot;prettyprint linenums lang-js&quot;&gt;let a = 1/new Object();
console.log(typeof a); //Number
console.log(a); //NaN
console.log(isNaN(a)); //true
&lt;/pre&gt;
&lt;p&gt;NaN属于特殊的Number类型,我们可以把它理解为坏数值,因为它属于数值计算中的错误,更加特殊的是它自己都不等价于自己NaN === NaN //false,我们只能用isNaN()来检测一个数字是否为NaN.&lt;/p&gt;
&lt;h1 id=&quot;类型判断&quot;&gt;类型判断&lt;/h1&gt;
&lt;h3 id=&quot;类型检测主要包括了-typeof、instanceof和tostring的三种方式来判断变量的类型。&quot;&gt;类型检测主要包括了: typeof、instanceof和toString的三种方式来判断变量的类型。&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;typeof: 用来检测基本类型&lt;/li&gt;
&lt;li&gt;toString: typeof的增强,用来判断内置的数据类型,无法判断构造函数创建的对象.&lt;/li&gt;
&lt;li&gt;instanceof: 用来判断使用构造函数创建的对象.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;typeof&quot;&gt;typeof&lt;/h2&gt;
&lt;p&gt;typeof接受一个值并返回它的类型，它有两种可能的语法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;typeof x&lt;/li&gt;
&lt;li&gt;typeof(x)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当在primitive类型上使用typeof检测变量类型时，我们总能得到我们想要的结果，比如&lt;/p&gt;
&lt;pre class=&quot;prettyprint linenums lang-js&quot;&gt;typeof 1; // &quot;number&quot;
typeof &quot;&quot;; // &quot;string&quot;
typeof true; // &quot;boolean&quot;
typeof bla; // &quot;undefined&quot;
typeof undefined; // &quot;undefined&quot;
&lt;/pre&gt;
&lt;p&gt;而当在object类型上使用typeof检测时，有时可能并不能得到你想要的结果，比如：&lt;/p&gt;
&lt;pre class=&quot;prettyprint linenums lang-js&quot;&gt;typeof []; // &quot;object&quot;
typeof null; // &quot;object&quot;
typeof /regex/ // &quot;object&quot;
typeof new String(&quot;&quot;); // &quot;object&quot;
typeof function(){}; // &quot;function&quot;
&lt;/pre&gt;
&lt;p&gt;这里的[]返回的确却是object，这可能并不是你想要的，因为数组是一个特殊的对象，有时候这可能并不是你想要的结果。&lt;/p&gt;
&lt;p&gt;对于这里的null返回的确却是object，wtf，有些人说null被认为是没有一个对象。&lt;/p&gt;
&lt;p&gt;当你对于typeof检测数据类型不确定时，请谨慎使用。&lt;/p&gt;
&lt;h2 id=&quot;tostring&quot;&gt;toString&lt;/h2&gt;
&lt;p&gt;toString不管是对于object类型还是primitive类型，都能得到你想要的结果：&lt;/p&gt;
&lt;pre class=&quot;prettyprint linenums lang-js&quot;&gt;let toClass = {}.toString;
console.log(toClass.call(123));
console.log(toClass.call(true));
console.log(toClass.call(Symbol(&#39;foo&#39;)));
console.log(toClass.call(&#39;some string&#39;));
console.log(toClass.call([1, 2]));
console.log(toClass.call(new Date()));
console.log(toClass.call({
    a: &#39;a&#39;
}));
// output
[object Number]
[object Boolean]
[object Symbol]
[object String]
[object Array]
[object Date]
[object Object]
&lt;/pre&gt;
&lt;h2 id=&quot;instanceof&quot;&gt;instanceof&lt;/h2&gt;
&lt;p&gt;对于使用构造函数创建的对象，我们通常使用instanceof来判断某一实例是否属于某种类型，例如：a instanceof Person，其内部原理实际上是判断Person.prototype是否在a实例的原型链中，其原理可以用下面的函数来表达：&lt;/p&gt;
&lt;pre class=&quot;prettyprint linenums lang-js&quot;&gt;function instance_of(V, F) {
  let O = F.prototype;
  V = V.__proto__;
  while (true) {
    if (V === null)
      return false;
    if (O === V)
      return true;
    V = V.__proto__;
  }
}
// use
function Person() {
}
let a = new Person();
// true
console.log(instance_of(a, Person));
&lt;/pre&gt;
</description>
        </item>
        
        <item>
            <title>JavaScript 字符串常用方法</title>
            <link>Homepage link/articles/javascript-string.html?utm_source=rss&amp;utm_medium=rss&amp;utm_campaign=rss</link>
            <guid>Homepage link/articles/javascript-string.html</guid>
            <author>chl01003698@126.com chuhongliang</author>
            <pubDate>Tue, 28 Jan 2020 00:00:00 +0800</pubDate>
            <description>&lt;h4 id=&quot;1-code-stringprototypeindexof-code-从字符串对象中返回首个被发现的给定值的索引，没找到返回-1&quot;&gt;1. &lt;code&gt;String.prototype.indexOf()&lt;/code&gt; 从字符串对象中返回首个被发现的给定值的索引，没找到返回-1&lt;/h4&gt;
&lt;pre class=&quot;prettyprint linenums lang-js&quot;&gt;let str = &#39;abcde&#39;;
let index = str.indexOf(&#39;c&#39;);
console.log(index);//2
&lt;/pre&gt;
&lt;h4 id=&quot;2-code-stringprototypelastindexof-code-从字符串对象中返回最后一个被发现的给定值的索引，没找到返回-1&quot;&gt;2. &lt;code&gt;String.prototype.lastIndexOf()&lt;/code&gt; 从字符串对象中返回最后一个被发现的给定值的索引，没找到返回-1&lt;/h4&gt;
&lt;pre class=&quot;prettyprint linenums lang-js&quot;&gt;let str = &#39;dabcde&#39;;
let index = str.lastIndexOf(&#39;d&#39;);
console.log(index);//4
&lt;/pre&gt;
&lt;h4 id=&quot;3-code-stringprototypecharat-code-返回特定位置的字符&quot;&gt;3. &lt;code&gt;String.prototype.charAt()&lt;/code&gt; 返回特定位置的字符&lt;/h4&gt;
&lt;pre class=&quot;prettyprint linenums lang-js&quot;&gt;let str = &#39;dabcde&#39;;
let char = str.charAt(3);
console.log(char);//c
&lt;/pre&gt;
&lt;h4 id=&quot;4-code-stringprototypesplit-code-将字符串分割为数组&quot;&gt;4. &lt;code&gt;String.prototype.split()&lt;/code&gt; 将字符串分割为数组&lt;/h4&gt;
&lt;pre class=&quot;prettyprint linenums lang-js&quot;&gt;let str = &#39;dabcde&#39;;
let arr = str.split(&#39;&#39;);
console.log(arr);//[ &#39;d&#39;, &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39; ]
&lt;/pre&gt;
&lt;h4 id=&quot;5-code-stringprototypeincludes-code-判断一个字符串是否包含某个字符&quot;&gt;5. &lt;code&gt;String.prototype.includes()&lt;/code&gt; 判断一个字符串是否包含某个字符&lt;/h4&gt;
&lt;pre class=&quot;prettyprint linenums lang-js&quot;&gt;let str = &#39;dabcde&#39;;
let flag = str.includes(&#39;ab&#39;);
console.log(flag);//true
&lt;/pre&gt;
&lt;h4 id=&quot;6-code-stringprototypeslice-code-摘取一个字符串区域，返回一个新字符串&quot;&gt;6. &lt;code&gt;String.prototype.slice()&lt;/code&gt; 摘取一个字符串区域，返回一个新字符串&lt;/h4&gt;
&lt;p&gt;&emsp;&lt;strong&gt;参数&lt;/strong&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;start&lt;/strong&gt;: number 起始位置(包括) 必需，可以是负整数&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;end&lt;/strong&gt;: number 结束位置(不包括) 可选，可以是负整数&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class=&quot;prettyprint linenums lang-js&quot;&gt;let str = &#39;dabcde&#39;;
let newStr = str.slice(0, 3);
console.log(newStr);//dab
&lt;/pre&gt;
&lt;h4 id=&quot;7-code-stringprototypesubstring-code-返回在字符串中指定两个下标之间的字符&quot;&gt;7. &lt;code&gt;String.prototype.substring()&lt;/code&gt; 返回在字符串中指定两个下标之间的字符&lt;/h4&gt;
&lt;p&gt;&emsp;&lt;strong&gt;参数&lt;/strong&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;start&lt;/strong&gt;: number 起始位置(包括) 必需，非负整数&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;end&lt;/strong&gt;: number 结束位置(不包括) 可选，非负整数&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class=&quot;prettyprint linenums lang-js&quot;&gt;let str = &#39;dabcde&#39;;
let newStr = str.substring(0, 3);
console.log(newStr);//dab
&lt;/pre&gt;
&lt;h4 id=&quot;8-code-stringprototypesubstr-code-通过指定字符数返回在指定位置开始的字符串中的字符。&quot;&gt;8. &lt;code&gt;String.prototype.substr()&lt;/code&gt; 通过指定字符数返回在指定位置开始的字符串中的字符。&lt;/h4&gt;
&lt;p&gt;&emsp;&lt;strong&gt;参数&lt;/strong&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;from&lt;/strong&gt;: number 起始位置 必需，可以是负整数&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;length&lt;/strong&gt;: number 长度 可选，非负整数&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class=&quot;prettyprint linenums lang-js&quot;&gt;let str = &#39;dabcde&#39;;
let newStr = str.substr(0, 3);
console.log(newStr);//dab
&lt;/pre&gt;
&lt;h4 id=&quot;9-code-stringprototypetrim-code-从字符串的开始和结尾去除空格&quot;&gt;9.  &lt;code&gt;String.prototype.trim()&lt;/code&gt; 从字符串的开始和结尾去除空格&lt;/h4&gt;
&lt;pre class=&quot;prettyprint linenums lang-js&quot;&gt;let str = &#39; dabcde &#39;;
let newStr = str.trim();
console.log(newStr);//dabcde
&lt;/pre&gt;
&lt;h4 id=&quot;10-code-stringprototypeconcat-code-连接两个字符串，返回新字符串&quot;&gt;10. &lt;code&gt;String.prototype.concat()&lt;/code&gt; 连接两个字符串，返回新字符串&lt;/h4&gt;
&lt;pre class=&quot;prettyprint linenums lang-js&quot;&gt;let str1 = &#39;dabcde&#39;;
let str2 = &#39;fghijk&#39;;
let str3 = str1.concat(str2);
console.log(str3);//dabcdefghijk
&lt;/pre&gt;
&lt;h4 id=&quot;11-code-stringprototypematch-code-使用正则表达式&quot;&gt;11. &lt;code&gt;String.prototype.match()&lt;/code&gt; 使用正则表达式&lt;/h4&gt;
&lt;pre class=&quot;prettyprint linenums lang-js&quot;&gt;let str = &#39;cat, bat, fat, sat&#39;;
let regExp = /.at/g;
let result = str.match(regExp);
console.log(result);//[ &#39;cat&#39;, &#39;bat&#39;, &#39;fat&#39;, &#39;sat&#39; ]
&lt;/pre&gt;
&lt;h4 id=&quot;12-code-stringprototypetest-code-用于检测一个字符串是否匹配某个模式&quot;&gt;12. &lt;code&gt;String.prototype.test()&lt;/code&gt; 用于检测一个字符串是否匹配某个模式&lt;/h4&gt;
&lt;pre class=&quot;prettyprint linenums lang-js&quot;&gt;let str = &#39;cat, bat, fat, sat&#39;;
let regExp = /.at/g;
let result = regExp.test(str);
console.log(result);//true
&lt;/pre&gt;
&lt;h4 id=&quot;13-code-stringprototypetolowercase-code-把字符串转换为小写&quot;&gt;13. &lt;code&gt;String.prototype.toLowerCase()&lt;/code&gt; 把字符串转换为小写&lt;/h4&gt;
&lt;pre class=&quot;prettyprint linenums lang-js&quot;&gt;let str = &#39;CAT, BAT, FAT, SAT&#39;;
let result = str.toLowerCase();
console.log(result);//cat, bat, fat, sat
&lt;/pre&gt;
&lt;h4 id=&quot;14-code-stringprototypetouppercase-code-把字符串转换为大写&quot;&gt;14. &lt;code&gt;String.prototype.toUpperCase()&lt;/code&gt; 把字符串转换为大写&lt;/h4&gt;
&lt;pre class=&quot;prettyprint linenums lang-js&quot;&gt;let str = &#39;cat, bat, fat, sat&#39;;
let result = str.toUpperCase();
console.log(result);//CAT, BAT, FAT, SAT
&lt;/pre&gt;
</description>
        </item>
        
        <item>
            <title>JavaScript Object常用方法</title>
            <link>Homepage link/articles/javascript-object.html?utm_source=rss&amp;utm_medium=rss&amp;utm_campaign=rss</link>
            <guid>Homepage link/articles/javascript-object.html</guid>
            <author>chl01003698@126.com chuhongliang</author>
            <pubDate>Wed, 29 Jan 2020 00:00:00 +0800</pubDate>
            <description>&lt;blockquote&gt;
&lt;p&gt;Object类是所有JavaScript类的基类(父类)，并提供了一种创建自定义对象的简单方式，Object本身是一个函数，可以当作工具方法使用，将任意值转为对象。这个方法常用于保证某个值一定是对象。如果参数为空（或者为undefined和null），Object()返回一个空对象。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;1-code-objectassign-target-source1-source2-code-通过复制一个或多个对象来创建一个新对象&quot;&gt;1. &lt;code&gt;Object.assign(target,source1,source2,...)&lt;/code&gt; 通过复制一个或多个对象来创建一个新对象&lt;/h4&gt;
&lt;pre class=&quot;prettyprint linenums lang-js&quot;&gt;let person1 = {
  name: &#39;tom&#39;,
  age: 20,
  sex: 1,
}
let person2 = {
  name: &#39;jane&#39;,
  age: 40,
}
let person3 = Object.assign(person2, person1);
console.log(person3);//{ name: &#39;tom&#39;, age: 20, sex: 1 }
let person4 = Object.assign({}, person3);
console.log(person4);//{ name: &#39;tom&#39;, age: 20, sex: 1 }
&lt;/pre&gt;
&lt;h4 id=&quot;2-code-objectcreate-prototype-[propertiesobject]-code-使用指定的原型对象和属性创建一个新对象&quot;&gt;2. &lt;code&gt;Object.create(prototype,[propertiesObject])&lt;/code&gt; 使用指定的原型对象和属性创建一个新对象&lt;/h4&gt;
&lt;pre class=&quot;prettyprint linenums lang-js&quot;&gt;let parent = {
  x: 1,
  y: 2
}
let child = Object.create(parent, {
  z: {// z会成为创建对象的属性
    value: 3,             // 初始化赋值
    writable: true,       // 是否是可改写的
    configurable: true,   // 是否能够删除，是否能够被修改
    enumerable: true,     //是否可以用for in 进行枚举
  }
});
console.log(child);//{ z: 3 }
console.log(child.__proto__);// { x: 1, y: 2 }
&lt;/pre&gt;
&lt;h4 id=&quot;3-code-objectdefineproperty-obj-prop-descriptor-code-在一个对象上定义一个新属性，或者修改一个对象的现有属性，-并返回这个对象。&quot;&gt;3. &lt;code&gt;Object.defineProperty(obj,prop,descriptor)&lt;/code&gt; 在一个对象上定义一个新属性，或者修改一个对象的现有属性， 并返回这个对象。&lt;/h4&gt;
&lt;pre class=&quot;prettyprint linenums lang-js&quot;&gt;let parent = {
  x: 1,
  y: 2
}
Object.defineProperty(parent, &#39;z&#39;, {
  writable: true,
  configurable: true,
  value: 3,
  enumerable: true
});
console.log(parent);//{ x: 1, y: 2, z: 3 }
&lt;/pre&gt;
&lt;h4 id=&quot;4-code-objectdefineproperties-obj-props-code-在一个对象上定义一个新属性，或者修改一个对象的现有属性，-并返回这个对象。&quot;&gt;4. &lt;code&gt;Object.defineProperties(obj,props)&lt;/code&gt; 在一个对象上定义一个新属性，或者修改一个对象的现有属性， 并返回这个对象。&lt;/h4&gt;
&lt;pre class=&quot;prettyprint linenums lang-js&quot;&gt;let parent = {
  x: 1,
  y: 2
}
Object.defineProperties(parent, {
  z: {
    writable: true,
    configurable: true,
    value: 3,
    enumerable: true
  },
  i: {
    writable: true,
    configurable: true,
    value: 4,
    enumerable: true
  },
});
console.log(parent);//{ x: 1, y: 2, z: 3, i: 4 }
&lt;/pre&gt;
&lt;h4 id=&quot;5-code-objectkeys-code-返回一个给定对象的自身可枚举属性组成的数组，数组中属性名的排列顺序和使用-forin-循环遍历该对象时返回的顺序一致-（两者的主要区别是-一个-for-in-循环还会枚举其原型链上的属性）。&quot;&gt;5. &lt;code&gt;Object.keys()&lt;/code&gt; 返回一个给定对象的自身可枚举属性组成的数组，数组中属性名的排列顺序和使用 for...in 循环遍历该对象时返回的顺序一致 （两者的主要区别是 一个 for-in 循环还会枚举其原型链上的属性）。&lt;/h4&gt;
&lt;pre class=&quot;prettyprint linenums lang-js&quot;&gt;let person = {
  name: &#39;tom&#39;,
  age: 20,
  sex: 1,
}
console.log(Object.keys(person));//[ &#39;name&#39;, &#39;age&#39;, &#39;sex&#39; ]
&lt;/pre&gt;
&lt;h4 id=&quot;6-code-objectvalues-code-方法返回一个给定对象自己的所有可枚举属性值的数组，值的顺序与使用forin循环的顺序相同-区别在于-for-in-循环枚举原型链中的属性-。&quot;&gt;6. &lt;code&gt;Object.values()&lt;/code&gt; 方法返回一个给定对象自己的所有可枚举属性值的数组，值的顺序与使用for...in循环的顺序相同 ( 区别在于 for-in 循环枚举原型链中的属性 )。&lt;/h4&gt;
&lt;p&gt;Object.values会过滤属性名为 Symbol 值的属性。&lt;/p&gt;
&lt;pre class=&quot;prettyprint linenums lang-js&quot;&gt;let person = {
  name: &#39;tom&#39;,
  age: 20,
  sex: 1,
}
console.log(Object.values(person));//[ &#39;tom&#39;, 20, 1 ]
&lt;/pre&gt;
&lt;h4 id=&quot;7-code-objectentries-code-返回一个给定对象自身可枚举属性的键值对数组，其排列与使用-forin-循环遍历该对象时返回的顺序一致（区别在于-for-in-循环也枚举原型链中的属性）。&quot;&gt;7. &lt;code&gt;Object.entries()&lt;/code&gt;  返回一个给定对象自身可枚举属性的键值对数组，其排列与使用 for...in 循环遍历该对象时返回的顺序一致（区别在于 for-in 循环也枚举原型链中的属性）。&lt;/h4&gt;
&lt;pre class=&quot;prettyprint linenums lang-js&quot;&gt;let person = {
  name: &#39;tom&#39;,
  age: 20,
}
console.log(Object.entries(person));//[ [ &#39;name&#39;, &#39;tom&#39; ], [ &#39;age&#39;, 20 ] ]
&lt;/pre&gt;
&lt;h4 id=&quot;8-code-hasownproperty-code-判断对象自身属性中是否具有指定的属性。&quot;&gt;8. &lt;code&gt;hasOwnProperty()&lt;/code&gt; 判断对象自身属性中是否具有指定的属性。&lt;/h4&gt;
&lt;pre class=&quot;prettyprint linenums lang-js&quot;&gt;let person = {
  name: &#39;tom&#39;,
  age: 20,
}
console.log(person.hasOwnProperty(&#39;name&#39;));//true
console.log(person.hasOwnProperty(&#39;set&#39;));//false
&lt;/pre&gt;
&lt;h4 id=&quot;9-code-objectis-code-判断两个值是否相同。&quot;&gt;9. &lt;code&gt;Object.is()&lt;/code&gt; 判断两个值是否相同。&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;两个值都是 undefined&lt;/li&gt;
&lt;li&gt;两个值都是 null&lt;/li&gt;
&lt;li&gt;两个值都是 true 或者都是 false&lt;/li&gt;
&lt;li&gt;两个值是由相同个数的字符按照相同的顺序组成的字符串&lt;/li&gt;
&lt;li&gt;两个值指向同一个对象&lt;/li&gt;
&lt;li&gt;两个值都是数字并且&lt;ul&gt;
&lt;li&gt;都是正零 +0&lt;/li&gt;
&lt;li&gt;都是负零 -0&lt;/li&gt;
&lt;li&gt;都是 NaN&lt;/li&gt;
&lt;li&gt;都是除零和 NaN 外的其它同一个数字&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class=&quot;prettyprint linenums lang-js&quot;&gt;Object.is(&#39;foo&#39;, &#39;foo&#39;);     // true
Object.is(window, window);   // true

Object.is(&#39;foo&#39;, &#39;bar&#39;);     // false
Object.is([], []);           // false

let test = { a: 1 };
Object.is(test, test);       // true
Object.is(null, null);       // true
// 特例
Object.is(0, -0);            // false
Object.is(-0, -0);           // true
Object.is(NaN, 0/0);         // true
&lt;/pre&gt;
&lt;h4 id=&quot;10-code-objectfreeze-code-冻结一个对象，冻结指的是不能向这个对象添加新的属性，不能修改其已有属性的值，不能删除已有属性，以及不能修改该对象已有属性的可枚举性、可配置性、可写性。也就是说，这个对象永远是不可变的。该方法返回被冻结的对象。&quot;&gt;10. &lt;code&gt;Object.freeze()&lt;/code&gt;冻结一个对象，冻结指的是不能向这个对象添加新的属性，不能修改其已有属性的值，不能删除已有属性，以及不能修改该对象已有属性的可枚举性、可配置性、可写性。也就是说，这个对象永远是不可变的。该方法返回被冻结的对象。&lt;/h4&gt;
&lt;pre class=&quot;prettyprint linenums lang-js&quot;&gt;let obj = {
  i: 10,
  x: 1,
  y: 2,
};
// 新的属性会被添加, 已存在的属性可能
// 会被修改或移除
obj.z = 3;
delete obj.i;

// 作为参数传递的对象与返回的对象都被冻结
// 所以不必保存返回的对象（因为两个对象全等）
let o = Object.freeze(obj);

o === obj; // true
Object.isFrozen(obj); // === true

// 现在任何改变都会失效
obj.x = 10; // 静默地不做任何事
obj.k = 4; // 静默地不添加此属性
console.log(obj);
&lt;/pre&gt;
&lt;h4 id=&quot;11-code-objectisfrozen-code-判断一个对象是否被冻结&quot;&gt;11. &lt;code&gt;Object.isFrozen()&lt;/code&gt; 判断一个对象是否被冻结.&lt;/h4&gt;
&lt;pre class=&quot;prettyprint linenums lang-js&quot;&gt;let obj = {
  i: 10,
};
Object.freeze(obj);
Object.isFrozen(obj); // === true
&lt;/pre&gt;
&lt;h4 id=&quot;12-code-objectpreventextensions-code-对象不能再添加新的属性。可修改，删除现有属性，不能添加新属性。&quot;&gt;12. &lt;code&gt;Object.preventExtensions()&lt;/code&gt;对象不能再添加新的属性。可修改，删除现有属性，不能添加新属性。&lt;/h4&gt;
&lt;pre class=&quot;prettyprint linenums lang-js&quot;&gt;let obj = {
  x: 1,
  y: 2,
  z: 3,
}
obj = Object.preventExtensions(obj);
console.log(obj);    // { x: 1, y: 2, z: 3 }
obj.i = 4;
console.log(obj)     // { x: 1, y: 2, z: 3 }
delete obj.z;
console.log(obj);    // { x: 1, y: 2 }
obj.k = 5;
console.log(obj)     // { x: 1, y: 2 }
&lt;/pre&gt;
&lt;h4 id=&quot;13-code-objectisextensible-code-判断对象是否是可扩展的，objectpreventextensions，objectseal-或-objectfreeze-方法都可以标记一个对象为不可扩展（non-extensible）&quot;&gt;13.&lt;code&gt;Object.isExtensible()&lt;/code&gt; 判断对象是否是可扩展的，Object.preventExtensions，Object.seal 或 Object.freeze 方法都可以标记一个对象为不可扩展（non-extensible）&lt;/h4&gt;
&lt;pre class=&quot;prettyprint linenums lang-js&quot;&gt;let obj = {
  x: 1,
}
console.log(Object.isExtensible(obj));// === true
Object.preventExtensions(obj);
// Object.freeze(obj);
// Object.seal(obj);
console.log(Object.isExtensible(obj));/// === false 
&lt;/pre&gt;
&lt;h4 id=&quot;14-code-objectseal-code-方法可以让一个对象密封，并返回被密封后的对象。密封一个对象会让这个对象变的不能添加新属性，且所有已有属性会变的不可配置。属性不可配置的效果就是属性变的不可删除，以及一个数据属性不能被重新定义成为访问器属性，或者反之。但属性的值仍然可以修改。尝试删除一个密封对象的属性或者将某个密封对象的属性从数据属性转换成访问器属性，结果会静默失败或抛出typeerror-异常-不会影响从原型链上继承的属性。但-strong-proto-strong-属性的值也会不能修改。&quot;&gt;14. &lt;code&gt;Object.seal()&lt;/code&gt;方法可以让一个对象密封，并返回被密封后的对象。密封一个对象会让这个对象变的不能添加新属性，且所有已有属性会变的不可配置。属性不可配置的效果就是属性变的不可删除，以及一个数据属性不能被重新定义成为访问器属性，或者反之。但属性的值仍然可以修改。尝试删除一个密封对象的属性或者将某个密封对象的属性从数据属性转换成访问器属性，结果会静默失败或抛出TypeError 异常. 不会影响从原型链上继承的属性。但 &lt;strong&gt;proto&lt;/strong&gt; (  ) 属性的值也会不能修改。&lt;/h4&gt;
&lt;pre class=&quot;prettyprint linenums lang-js&quot;&gt;let obj = {
    i: 10,
    x: 1,
};
// 可以添加新的属性,已有属性的值可以修改,可以删除
obj.y = 2;
delete obj.i;

let o = Object.seal(obj);

// 仍然可以修改密封对象上的属性的值.
obj.x = 20;

// 但你不能把一个数据属性重定义成访问器属性.
Object.defineProperty(obj, &quot;x&quot;, { get: function () { return 10; } }); // 抛出TypeError异常

// 现在,任何属性值以外的修改操作都会失败.
obj.z = 3; // 静默失败,新属性没有成功添加
delete obj.y; // 静默失败,属性没有删除成功

// 使用Object.defineProperty方法同样会抛出异常
Object.defineProperty(obj, &quot;k&quot;, { value: 17 }); // 抛出TypeError异常
Object.defineProperty(obj, &quot;x&quot;, { value: 100 }); // 成功将原有值改变
&lt;/pre&gt;
&lt;h4 id=&quot;15-code-objectissealed-code-判断一个对象是否被密封&quot;&gt;15. &lt;code&gt;Object.isSealed()&lt;/code&gt; 判断一个对象是否被密封&lt;/h4&gt;
&lt;pre class=&quot;prettyprint linenums lang-js&quot;&gt;let obj = {
    x: 1,
};
Object.seal(obj);
console.log(Object.isSealed(obj)); // === true;
&lt;/pre&gt;
</description>
        </item>
        
        <item>
            <title>JavaScript 数组常用方法</title>
            <link>Homepage link/articles/javascript-array.html?utm_source=rss&amp;utm_medium=rss&amp;utm_campaign=rss</link>
            <guid>Homepage link/articles/javascript-array.html</guid>
            <author>chl01003698@126.com chuhongliang</author>
            <pubDate>Wed, 29 Jan 2020 00:00:00 +0800</pubDate>
            <description>&lt;blockquote&gt;
&lt;p&gt;JavaScript 的数组是无类型的，数组元素可以是任意类型，同一个数组中的不同元素可能是对象或数组。数组元素的索引不一定要连续，元素之间可以有空隙，叫做稀疏数组 。每个数组都具有一个lengrh属性。针对非稀疏数组，length属性就是数组元素的个数，针对稀疏数组，元素的length属性比所有元素的索引要大。非稀疏是我们学习掌握的主要知识点。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;-strong-下面这些方法会改变数组自身的值：-strong-&quot;&gt;&lt;strong&gt;下面这些方法会改变数组自身的值：&lt;/strong&gt;&lt;/h3&gt;
&lt;h4 id=&quot;1-code-arrayprototypepop-code-删除数组的最后一个元素，并返回这个元素&quot;&gt;1. &lt;code&gt;Array.prototype.pop()&lt;/code&gt; 删除数组的最后一个元素，并返回这个元素&lt;/h4&gt;
&lt;pre class=&quot;prettyprint linenums lang-js&quot;&gt;let arr = [1, 2, 3];
let value = arr.pop();
console.log(value);// 3
&lt;/pre&gt;
&lt;h4 id=&quot;2-code-arrayprototypepush-code-在数组的末尾增加一个或多个元素，并返回数组长度&quot;&gt;2. &lt;code&gt;Array.prototype.push()&lt;/code&gt; 在数组的末尾增加一个或多个元素，并返回数组长度&lt;/h4&gt;
&lt;pre class=&quot;prettyprint linenums lang-js&quot;&gt;let arr = [1, 2, 3];
arr.push(4);
console.log(arr);// [ 1, 2, 3, 4 ]
&lt;/pre&gt;
&lt;h4 id=&quot;3-code-arrayprototypeshift-code-删除数组的第一个约束，并返回这个元素&quot;&gt;3. &lt;code&gt;Array.prototype.shift()&lt;/code&gt; 删除数组的第一个约束，并返回这个元素&lt;/h4&gt;
&lt;pre class=&quot;prettyprint linenums lang-js&quot;&gt;let arr = [1, 2, 3];
let value = arr.shift();
console.log(value);// 1
&lt;/pre&gt;
&lt;h4 id=&quot;4-code-arrayprototypeunshift-code-在数组的开头增加一个或多个元素，并返回数组长度&quot;&gt;4. &lt;code&gt;Array.prototype.unshift()&lt;/code&gt; 在数组的开头增加一个或多个元素，并返回数组长度&lt;/h4&gt;
&lt;pre class=&quot;prettyprint linenums lang-js&quot;&gt;let arr = [1, 2, 3];
arr.unshift(0);
console.log(arr);// [ 0, 1, 2, 3 ]
&lt;/pre&gt;
&lt;h4 id=&quot;5-code-arrayprototypesort-code-对数组进行排序，并返回当前数组。&quot;&gt;5. &lt;code&gt;Array.prototype.sort()&lt;/code&gt; 对数组进行排序，并返回当前数组。&lt;/h4&gt;
&lt;pre class=&quot;prettyprint linenums lang-js&quot;&gt;let arr = [3, 1, 2];
arr.sort();
console.log(arr);// [ 1, 2, 3 ]
arr.sort(function (a, b) {
  if (a &lt; b) return 1;
  if (a &gt; b) return -1;
  if (a === b) return 0;
})
console.log(arr);// [ 3, 2, 1 ]
&lt;/pre&gt;
&lt;h4 id=&quot;6-code-arrayprototypereverse-code-颠倒数组中元素的排列顺序。&quot;&gt;6. &lt;code&gt;Array.prototype.reverse()&lt;/code&gt; 颠倒数组中元素的排列顺序。&lt;/h4&gt;
&lt;pre class=&quot;prettyprint linenums lang-js&quot;&gt;let arr = [3, 2, 1];
arr.reverse();
console.log(arr);// [ 1, 2, 3 ]
&lt;/pre&gt;
&lt;h4 id=&quot;7-code-arrayprototypesplice-code-在任意位置给数组添加或删除任意个元素。&quot;&gt;7. &lt;code&gt;Array.prototype.splice()&lt;/code&gt; 在任意位置给数组添加或删除任意个元素。&lt;/h4&gt;
&lt;pre class=&quot;prettyprint linenums lang-js&quot;&gt;let arr = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;];
arr.splice(3, 0, &#39;d&#39;, &#39;e&#39;);//添加
console.log(arr);// [ &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39; ]
arr.splice(0, 2);//删除
console.log(arr);//[&#39;c&#39;, &#39;d&#39;, &#39;e&#39;]
&lt;/pre&gt;
&lt;p&gt;&nbsp;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&nbsp;&lt;/p&gt;
&lt;h3 id=&quot;-strong-下面这些方法不会改变数组自身的值，只会返回一个新的数组或者其他值：-strong-&quot;&gt;&lt;strong&gt;下面这些方法不会改变数组自身的值，只会返回一个新的数组或者其他值：&lt;/strong&gt;&lt;/h3&gt;
&lt;h4 id=&quot;1-code-arrayprototypeconcat-code-返回当前数组和其他若干数组或者若干个费数组值组合而成的新数组&quot;&gt;1. &lt;code&gt;Array.prototype.concat()&lt;/code&gt; 返回当前数组和其他若干数组或者若干个费数组值组合而成的新数组&lt;/h4&gt;
&lt;pre class=&quot;prettyprint linenums lang-js&quot;&gt;let arr1 = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;];
let arr2 = [&#39;d&#39;, &#39;e&#39;, &#39;f&#39;];
let arr3 = arr1.concat(arr2);
console.log(arr3);// [ &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39; ]
&lt;/pre&gt;
&lt;h4 id=&quot;2-code-arrayprototypeincludes-code-判断当前数组是否包含某指定的值。&quot;&gt;2. &lt;code&gt;Array.prototype.includes()&lt;/code&gt; 判断当前数组是否包含某指定的值。&lt;/h4&gt;
&lt;pre class=&quot;prettyprint linenums lang-js&quot;&gt;let arr = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;]
let result = arr.includes(&#39;c&#39;);
console.log(result);// true
&lt;/pre&gt;
&lt;h4 id=&quot;3-code-arrayprototypejoin-code-连接所有数组元素组成一个字符串&quot;&gt;3. &lt;code&gt;Array.prototype.join()&lt;/code&gt; 连接所有数组元素组成一个字符串&lt;/h4&gt;
&lt;pre class=&quot;prettyprint linenums lang-js&quot;&gt;let arr = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;]
let result = arr.join(&#39;&#39;);
console.log(result);// abcdef
&lt;/pre&gt;
&lt;h4 id=&quot;4-code-arrayprototypeslice-code-抽取当前数组中的一段元素组合成一个新数组&quot;&gt;4. &lt;code&gt;Array.prototype.slice()&lt;/code&gt; 抽取当前数组中的一段元素组合成一个新数组&lt;/h4&gt;
&lt;pre class=&quot;prettyprint linenums lang-js&quot;&gt;let arr1 = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;]
let arr2 = arr1.slice(0, 3);
console.log(arr2);// [ &#39;a&#39;, &#39;b&#39;, &#39;c&#39; ]
&lt;/pre&gt;
&lt;h4 id=&quot;5-code-arrayprototypetostring-code-返回由数组元素组成的字符串&quot;&gt;5. &lt;code&gt;Array.prototype.toString()&lt;/code&gt; 返回由数组元素组成的字符串&lt;/h4&gt;
&lt;pre class=&quot;prettyprint linenums lang-js&quot;&gt;let arr = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;]
let result = arr.toString();
console.log(result);// a,b,c,d,e,f
&lt;/pre&gt;
&lt;h4 id=&quot;6-code-arrayprototypeindexof-code-返回数组中第一个与指定值相等的元素的索引，如果找不到返回-1&quot;&gt;6. &lt;code&gt;Array.prototype.indexOf()&lt;/code&gt; 返回数组中第一个与指定值相等的元素的索引，如果找不到返回-1&lt;/h4&gt;
&lt;pre class=&quot;prettyprint linenums lang-js&quot;&gt;let arr = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;]
let index = arr.indexOf(&#39;a&#39;);
console.log(index);// 0
&lt;/pre&gt;
&lt;h4 id=&quot;7-code-arrayprototypelastindexof-code-返回数组中最后一个与指定值相等的元素的索引，如果找不到返回-1&quot;&gt;7. &lt;code&gt;Array.prototype.lastIndexOf()&lt;/code&gt; 返回数组中最后一个与指定值相等的元素的索引，如果找不到返回-1&lt;/h4&gt;
&lt;pre class=&quot;prettyprint linenums lang-js&quot;&gt;let arr = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;, &#39;a&#39;]
let index = arr.lastIndexOf(&#39;a&#39;);
console.log(index);// 6
&lt;/pre&gt;
&lt;p&gt;&nbsp;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&nbsp;&lt;/p&gt;
&lt;h3 id=&quot;-strong-遍历方法-strong-&quot;&gt;&lt;strong&gt;遍历方法:&lt;/strong&gt;&lt;/h3&gt;
&lt;h4 id=&quot;1-code-arrayprototypeforeach-code-为数组中每一个元素执行一次回调。&quot;&gt;1. &lt;code&gt;Array.prototype.forEach()&lt;/code&gt; 为数组中每一个元素执行一次回调。&lt;/h4&gt;
&lt;pre class=&quot;prettyprint linenums lang-js&quot;&gt;let arr = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;, &#39;a&#39;]
arr.forEach((item, index, array) =&gt; {
    if (item === &#39;a&#39;) {
        array.splice(index, 1);
    }
});
console.log(arr);//[ &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39; ]
&lt;/pre&gt;
&lt;h4 id=&quot;2-code-arrayprototypeevery-code-如果数组中每个元素都满足测试函数，则返回true，否则返回false；&quot;&gt;2. &lt;code&gt;Array.prototype.every()&lt;/code&gt; 如果数组中每个元素都满足测试函数，则返回true，否则返回false；&lt;/h4&gt;
&lt;pre class=&quot;prettyprint linenums lang-js&quot;&gt;let arr = [1, 2, 3, 4, 5];
let result = arr.every((item) =&gt; {
  return item &gt; 0;
});
console.log(result);// === true
&lt;/pre&gt;
&lt;h4 id=&quot;3-code-arrayprototypesome-code-如果数组中至少有一个元素满足测试函数，则返回true，否则返回false&quot;&gt;3. &lt;code&gt;Array.prototype.some()&lt;/code&gt; 如果数组中至少有一个元素满足测试函数，则返回true，否则返回false&lt;/h4&gt;
&lt;pre class=&quot;prettyprint linenums lang-js&quot;&gt;let arr = [1, 2, 3, -1, 4, 5];
let result = arr.some((item) =&gt; {
  return item &lt; 0;
});
console.log(result);// === true
&lt;/pre&gt;
&lt;h4 id=&quot;4-code-arrayprototypefilter-code-将所有在过滤函数中返回true的数组元素放假一个新数组中并返回。&quot;&gt;4. &lt;code&gt;Array.prototype.filter()&lt;/code&gt; 将所有在过滤函数中返回true的数组元素放假一个新数组中并返回。&lt;/h4&gt;
&lt;pre class=&quot;prettyprint linenums lang-js&quot;&gt;let arr = [1, 2, 3, -1, 4, 5];
let result = arr.filter((item) =&gt; {
  return item &gt; 0;
});
console.log(result);// [ 1, 2, 3, 4, 5 ]
&lt;/pre&gt;
&lt;h4 id=&quot;5-code-arrayprototypefind-code-找到第一个满足测试函数的元素并返回那个元素的值，如果找不到，返回undefined&quot;&gt;5. &lt;code&gt;Array.prototype.find()&lt;/code&gt; 找到第一个满足测试函数的元素并返回那个元素的值，如果找不到，返回undefined&lt;/h4&gt;
&lt;pre class=&quot;prettyprint linenums lang-js&quot;&gt;let arr = [1, 2, 3, -1, 4, 5];
let result = arr.find((item) =&gt; {
  return item &lt; 0;
});
console.log(result);// -1
&lt;/pre&gt;
&lt;h4 id=&quot;6-code-arrayprototypemap-code-返回一个由回调函数的返回值组成的新数组-不会改变原始数组。&quot;&gt;6. &lt;code&gt;Array.prototype.map()&lt;/code&gt; 返回一个由回调函数的返回值组成的新数组,不会改变原始数组。&lt;/h4&gt;
&lt;pre class=&quot;prettyprint linenums lang-js&quot;&gt;let arr = [1, -3, 3, -1, 4, 5];
let result = arr.map((item) =&gt; {
  return Math.abs(item);
});
console.log(result);// [ 1, 3, 3, 1, 4, 5 ]
&lt;/pre&gt;
&lt;h4 id=&quot;7-code-arrayprototypereduce-code-从左到右为每个元素执行一次回调函数，并把上次回调函数的返回值放在一个暂存器中传给下次回调函数，并返回最后一次回调函数的返回值。&quot;&gt;7. &lt;code&gt;Array.prototype.reduce()&lt;/code&gt; 从左到右为每个元素执行一次回调函数，并把上次回调函数的返回值放在一个暂存器中传给下次回调函数，并返回最后一次回调函数的返回值。&lt;/h4&gt;
&lt;pre class=&quot;prettyprint linenums lang-js&quot;&gt;let arr = [1, -3, 3, -1, 4, 5];
/**
 * previousValue: 表示上一次调用回调时的返回值，或者初始值 init
 * currentValue: 表示当前正在处理的数组元素
 * currentIndex: 表示当前正在处理的数组元素的索引，若提供 init 值，则索引为0，否则索引为1；
 * array: 原数组
 */
let result = arr.reduce((previousValue, currentValue) =&gt; {
  return previousValue + currentValue;//求和
});
console.log(result);// 9
&lt;/pre&gt;
&lt;hr&gt;
&lt;h2 id=&quot;arrayprototypesort-的底层实现及应用&quot;&gt;Array.prototype.sort()的底层实现及应用&lt;/h2&gt;
&lt;h3 id=&quot;v8-引擎的-arrayjs&quot;&gt;V8 引擎的 array.js&lt;/h3&gt;
&lt;p&gt;js中的sort()方法用于对数组元素进行排序，具体是如何实现的？查阅资料发现，V8 引擎 sort 函数只给出了两种排序 InsertionSort 和 QuickSort，数组长度小于等于 22 的用插入排序 InsertionSort，比22大的数组则使用快速排序 QuickSort。源码中这样写道：&lt;/p&gt;
&lt;pre class=&quot;prettyprint linenums lang-js&quot;&gt;// In-place QuickSort algorithm. 
// For short (length &lt;= 22) arrays, insertion sort is used for efficiency.
&lt;/pre&gt;
&lt;h3 id=&quot;其他引擎的sort实现方式&quot;&gt;其他引擎的sort实现方式&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Mozilla/Firefox : 归并排序（jsarray.c 源码） &lt;/li&gt;
&lt;li&gt;Webkit ：底层实现用了 C++ 库中的 qsort() 方法（JSArray.cpp 源码）&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        
        <item>
            <title>JavaScript Math常用方法</title>
            <link>Homepage link/articles/javascript-math.html?utm_source=rss&amp;utm_medium=rss&amp;utm_campaign=rss</link>
            <guid>Homepage link/articles/javascript-math.html</guid>
            <author>chl01003698@126.com chuhongliang</author>
            <pubDate>Thu, 30 Jan 2020 00:00:00 +0800</pubDate>
            <description>&lt;blockquote&gt;
&lt;p&gt;Math 是一个内置对象， 它具有数学常数和函数的属性和方法。不是一个函数对象。与其他全局对象不同的是，Math 不是一个构造器。 Math 的所有属性与方法都是静态的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;1-code-mathabs-x-code-返回绝对值&quot;&gt;1. &lt;code&gt;Math.abs(x)&lt;/code&gt; 返回绝对值&lt;/h4&gt;
&lt;pre class=&quot;prettyprint linenums lang-js&quot;&gt;let a = -1;
console.log(Math.abs(a));// 1
&lt;/pre&gt;
&lt;h4 id=&quot;2-code-mathceil-x-code-返回x向上取整后的值&quot;&gt;2. &lt;code&gt;Math.ceil(x)&lt;/code&gt; 返回x向上取整后的值&lt;/h4&gt;
&lt;pre class=&quot;prettyprint linenums lang-js&quot;&gt;let a = 1.5;
let b = 1.4;
console.log(Math.ceil(a));// 2
console.log(Math.ceil(b));// 2
&lt;/pre&gt;
&lt;h4 id=&quot;3-code-mathfloor-x-code-返回x向下取整后的值&quot;&gt;3. &lt;code&gt;Math.floor(x)&lt;/code&gt; 返回x向下取整后的值&lt;/h4&gt;
&lt;pre class=&quot;prettyprint linenums lang-js&quot;&gt;let a = 1.5;
let b = 1.4;
console.log(Math.floor(a));// 1
console.log(Math.floor(b));// 1
&lt;/pre&gt;
&lt;h4 id=&quot;4-code-mathmin-x-code-返回最小值&quot;&gt;4. &lt;code&gt;Math.min(x)&lt;/code&gt;  返回最小值&lt;/h4&gt;
&lt;pre class=&quot;prettyprint linenums lang-js&quot;&gt;let a = 3;
let b = 1;
let c = 2;
let result = Math.min(a, b, c);
console.log(result);// 1
&lt;/pre&gt;
&lt;h4 id=&quot;5-code-mathmax-x-code-返回最大值&quot;&gt;5. &lt;code&gt;Math.max(x)&lt;/code&gt; 返回最大值&lt;/h4&gt;
&lt;pre class=&quot;prettyprint linenums lang-js&quot;&gt;let a = 3;
let b = 1;
let c = 2;
let result = Math.max(a, b, c);
console.log(result);// 3
&lt;/pre&gt;
&lt;h4 id=&quot;6-code-mathpow-x-y-code-返回x的y次幂&quot;&gt;6. &lt;code&gt;Math.pow(x, y)&lt;/code&gt; 返回x的y次幂&lt;/h4&gt;
&lt;pre class=&quot;prettyprint linenums lang-js&quot;&gt;let a = 3;
let b = 3;
let result = Math.pow(a, b);
console.log(result);// 27
&lt;/pre&gt;
&lt;h4 id=&quot;7-code-mathrandom-x-code-返回0-1之间的伪随机数&quot;&gt;7. &lt;code&gt;Math.random(x)&lt;/code&gt; 返回0-1之间的伪随机数&lt;/h4&gt;
&lt;pre class=&quot;prettyprint linenums lang-js&quot;&gt;let result = Math.floor(Math.random() * 10);
console.log(result);// 10 以内的随机数
&lt;/pre&gt;
&lt;h4 id=&quot;8-code-mathround-x-code-返回四舍五入后的整数&quot;&gt;8. &lt;code&gt;Math.round(x)&lt;/code&gt; 返回四舍五入后的整数&lt;/h4&gt;
&lt;pre class=&quot;prettyprint linenums lang-js&quot;&gt;let a = 1.5;
let b = 1.4;
console.log(Math.round(a));// 2
console.log(Math.round(b));// 1
&lt;/pre&gt;
&lt;h4 id=&quot;9-code-mathsign-x-code-返回x的符号函数，判断x是正数、负数还是0&quot;&gt;9. &lt;code&gt;Math.sign(x)&lt;/code&gt; 返回x的符号函数，判断x是正数、负数还是0&lt;/h4&gt;
&lt;pre class=&quot;prettyprint linenums lang-js&quot;&gt;let a = 1.5;
let b = - 1.4;
let c = 0;
console.log(Math.sign(a));// 1
console.log(Math.sign(b));// -1
console.log(Math.sign(c));// 0
&lt;/pre&gt;
</description>
        </item>
        
        <item>
            <title>JavaScript 原型</title>
            <link>Homepage link/articles/javascript-prototype.html?utm_source=rss&amp;utm_medium=rss&amp;utm_campaign=rss</link>
            <guid>Homepage link/articles/javascript-prototype.html</guid>
            <author>chl01003698@126.com chuhongliang</author>
            <pubDate>Thu, 30 Jan 2020 00:00:00 +0800</pubDate>
            <description>&lt;h1 id=&quot;-strong-原型-strong-prototype&quot;&gt;&lt;strong&gt;原型&lt;/strong&gt; prototype&lt;/h1&gt;
&lt;p&gt;我们所创建的每一个函数，解析器都会向函数中添加一个属性prototype，这个属性对应着一个对象，这个对象就是我们所谓的原型对象.&lt;/p&gt;
&lt;p&gt;如果函数作为普通函数调用prototype没有任何作用, 当函数以构造函数的形式调用时，它所创建的对象中都会有一个隐含的属性，指向该构造函数的原型对象，我们可以通过&lt;strong&gt;proto&lt;/strong&gt;来访问该属性.&lt;/p&gt;
&lt;p&gt;原型对象就相当于一个公共的区域，所有同一个类的实例都可以访问到这个原型对象，
我们可以将对象中共有的内容，统一设置到原型对象中。
当我们访问对象的一个属性或方法时，它会先在对象自身中寻找，如果有则直接使用，
如果没有则会去原型对象中寻找，如果找到则直接使用
以后我们创建构造函数时，可以将这些对象共有的属性和方法，统一添加到构造函数的原型对象中，这样不用分别为每一个对象添加，也不会影响到全局作用域，就可以使每个对象都具有这些属性和方法了&lt;/p&gt;
&lt;p&gt;例如: &lt;code&gt;hasOwnProperty()&lt;/code&gt;方法存在于Obejct原型对象中,它便可以被任何对象当做自己的方法使用.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;object.hasOwnProperty( propertyName )&lt;/code&gt;
&lt;code&gt;hasOwnProperty()&lt;/code&gt;函数的返回值为&lt;code&gt;Boolean&lt;/code&gt;类型。如果对象&lt;code&gt;object&lt;/code&gt;具有名称为&lt;code&gt;propertyName&lt;/code&gt;的属性，则返回&lt;code&gt;true&lt;/code&gt;，否则返回&lt;code&gt;false&lt;/code&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;prettyprint linenums lang-javascript&quot;&gt;let pet = {
  name: &quot;狗&quot;,
};
console.log(pet.hasOwnProperty(&quot;name&quot;)); //true
console.log(pet.hasOwnProperty(&quot;hasOwnProperty&quot;)); //false
console.log(Object.prototype.hasOwnProperty(&quot;hasOwnProperty&quot;)); //true
&lt;/pre&gt;
&lt;p&gt;由以上代码可知,&lt;code&gt;hasOwnProperty()&lt;/code&gt;并不存在于&lt;code&gt;pet&lt;/code&gt;对象中,但是&lt;code&gt;pet&lt;/code&gt;依然可以拥有此方法.&lt;/p&gt;
&lt;h2 id=&quot;-code-__proto__-code-与-code-prototype-code-&quot;&gt;&lt;code&gt;__proto__&lt;/code&gt;与&lt;code&gt;prototype&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;实例对象的&lt;code&gt;__proto__&lt;/code&gt;属性,指向原型对象,我们便可以通过此属性找到原型对象.&lt;/p&gt;
&lt;pre class=&quot;prettyprint linenums lang-javascript&quot;&gt;function pet(name) {
  this.name = name;
}
let dog = new pet(&#39;狗&#39;);
console.log(dog.__proto__ === pet.prototype); //true
&lt;/pre&gt;
&lt;h4 id=&quot;-code-getprototypeof-code-获取原型对象&quot;&gt;&lt;code&gt;getPrototypeOf()&lt;/code&gt; 获取原型对象.&lt;/h4&gt;
&lt;pre class=&quot;prettyprint linenums lang-javascript&quot;&gt;function pet(name) {
    this.name = name;
}
let dog = new pet(&#39;狗&#39;);
console.log(Object.getPrototypeOf(dog) === pet.prototype); //true
&lt;/pre&gt;
&lt;h4 id=&quot;-code-isprototypeof-code-来检验某个对象是否是另一个对象的原型对象&quot;&gt;&lt;code&gt;isPrototypeOf&lt;/code&gt; 来检验某个对象是否是另一个对象的原型对象.&lt;/h4&gt;
&lt;pre class=&quot;prettyprint linenums lang-javascript&quot;&gt;function pet(name) {
    this.name = name;
}
let dog = new pet(&#39;狗&#39;);
console.log(pet.prototype.isPrototypeOf(dog)); //true
&lt;/pre&gt;
&lt;h2 id=&quot;-strong-原型链-strong-&quot;&gt;&lt;strong&gt;原型链&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;实例对象方法调用,是先在实例对象内部找,如果找到则立即返回调用,如果没有找到就顺着&lt;code&gt;__proto__&lt;/code&gt;向上寻找,如果找到该方法则调用,没有找到会直接报错,这便是&lt;strong&gt;原型链&lt;/strong&gt;.&lt;/p&gt;
&lt;pre class=&quot;prettyprint linenums lang-javascript&quot;&gt;function pet(name) {
    this.name = name;
}
let dog = new pet(&quot;狗&quot;);
// 先在dog对象实例中寻找`hasOwnProperty()`方法,发现不存在此方法
console.log(dog.hasOwnProperty(&quot;hasOwnProperty&quot;)); //fasle
// 在dog的原型对象dog.__proto__即pet.prototype中寻找hasOwnProperty()方法,依然没有找到
console.log(dog.__proto__.hasOwnProperty(&quot;hasOwnProperty&quot;)); //fasle
console.log(pet.prototype.hasOwnProperty(&quot;hasOwnProperty&quot;)); //false
console.log(dog.__proto__ === pet.prototype); //true

// 在pet.prototype原型对象pet.prototype.__proto__ 即Object.prototypehasOwnProperty()方法
console.log(pet.prototype.__proto__.hasOwnProperty(&quot;hasOwnProperty&quot;)); //true
console.log(dog.__proto__.__proto__.hasOwnProperty(&quot;hasOwnProperty&quot;)); //true
console.log(dog.__proto__.__proto__ === pet.prototype.__proto__); // true
console.log(dog.__proto__.__proto__ === Object.prototype); // true
&lt;/pre&gt;
&lt;h2 id=&quot;es6中的-code-__proto__-code-&quot;&gt;ES6中的 &lt;code&gt;__proto__&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;虽然&lt;code&gt;__proto__&lt;/code&gt;在最新的ECMA标准中被纳入了规范,但是由于&lt;code&gt;__proto__&lt;/code&gt;前后的双下划线，说明它本质上是一个内部属性，而不是一个正式的对外的 API.
标准明确规定，只有浏览器必须部署这个属性，其他运行环境不一定需要部署，而且新的代码最好认为这个属性是不存在的。因此，无论从语义的角度，还是从兼容性的角度，都不要使用这个属性，而是使用下面的&lt;code&gt;Object.setPrototypeOf()&lt;/code&gt;（写操作）、&lt;code&gt;Object.getPrototypeOf()&lt;/code&gt;（读操作）代替。&lt;/p&gt;
&lt;pre class=&quot;prettyprint linenums lang-javascript&quot;&gt;function pet(name) {
    this.name = name;
}
let dog = new pet(&quot;狗&quot;);
// getPrototypeOf
console.log(Object.getPrototypeOf(dog) === pet.prototype); //true

// setPrototypeOf
Object.setPrototypeOf(dog, { sound: &quot;汪汪&quot; });
console.log(dog.sound); //汪汪
&lt;/pre&gt;
&lt;h4 id=&quot;-code-objectsetprototypeof-code-只能生效当前实例-&quot;&gt;&lt;code&gt;Object.setPrototypeOf()&lt;/code&gt; 只能生效当前实例;&lt;/h4&gt;
&lt;pre class=&quot;prettyprint linenums lang-javascript&quot;&gt;function pet(name) {
    this.name = name;
}
let dog = new pet(&quot;狗&quot;);
let cat = new pet(&quot;猫&quot;);
Object.setPrototypeOf(dog, { sound: &quot;汪汪&quot; });
console.log(dog.sound); //汪汪
console.log(cat.sound); //undefind
&lt;/pre&gt;
</description>
        </item>
        
        <item>
            <title>JavaScript this</title>
            <link>Homepage link/articles/javascript-this.html?utm_source=rss&amp;utm_medium=rss&amp;utm_campaign=rss</link>
            <guid>Homepage link/articles/javascript-this.html</guid>
            <author>chl01003698@126.com chuhongliang</author>
            <pubDate>Thu, 30 Jan 2020 00:00:00 +0800</pubDate>
            <description>&lt;p&gt;javascript中this的指向在函数定义的时候是确定不了的，只有函数执行的时候才能确定this到底指向谁，实际上this的最终指向的是那个调用它的对象.&lt;/p&gt;
&lt;p&gt;javascript有执行上下文windows,或者函数。当前如果执行的直接属于windows，则取得的是windows的上下文。
当前如果执行的是函数，取得的是函数的上下文&lt;/p&gt;
&lt;pre class=&quot;prettyprint linenums lang-js&quot;&gt;function a(){
    var user = &quot;追梦子&quot;;
    console.log(this.user); //undefined
    console.log(this); //Window
}
a();
&lt;/pre&gt;
&lt;p&gt;按照我们上面说的this最终指向的是调用它的对象，这里的函数a实际是被Window对象所点出来的，下面的代码就可以证明。&lt;/p&gt;
&lt;pre class=&quot;prettyprint linenums lang-js&quot;&gt;function a(){
    var user = &quot;追梦子&quot;;
    console.log(this.user); //undefined
    console.log(this);　　//Window
}
window.a();
&lt;/pre&gt;
&lt;p&gt;和上面代码一样吧，其实alert也是window的一个属性，也是window点出来的。&lt;/p&gt;
&lt;h2 id=&quot;改变this指向&quot;&gt;改变this指向&lt;/h2&gt;
&lt;p&gt;apply, call, bind&lt;/p&gt;
&lt;p&gt;三者都可以把一个函数应用到其他对象上，注意不是自身对象．apply,call是直接执行函数调用，bind是绑定，执行需要再次调用．apply和call的区别是apply接受数组作为参数，而call是接受逗号分隔的无限多个参数列表，&lt;/p&gt;
&lt;pre class=&quot;prettyprint linenums lang-js&quot;&gt;function Person() {
}
Person.prototype.sayName() { alert(this.name); }

letobj = {name: &#39;michaelqin&#39;}; // 注意这是一个普通对象，它不是Person的实例

//apply
Person.prototype.sayName.apply(obj, [param1, param2, param3]);

// call
Person.prototype.sayName.call(obj, param1, param2, param3);

// bind
let sn = Person.prototype.sayName.bind(obj);
sn([param1, param2, param3]); // bind需要先绑定，再执行
sn(param1, param2, param3); // bind需要先绑定，再执行
&lt;/pre&gt;
&lt;h2 id=&quot;caller-callee和arguments的区别&quot;&gt;caller, callee和arguments的区别&lt;/h2&gt;
&lt;p&gt;caller,callee之间的关系就像是employer和employee之间的关系，就是调用与被调用的关系，二者返回的都是函数对象引用．arguments是函数的所有参数列表，它是一个类数组的变量．&lt;/p&gt;
&lt;pre class=&quot;prettyprint linenums lang-js&quot;&gt;function parent(param1, param2, param3) {
    child(param1, param2, param3);
}

function child() {
    console.log(arguments); // { &#39;0&#39;: &#39;mqin1&#39;, &#39;1&#39;: &#39;mqin2&#39;, &#39;2&#39;: &#39;mqin3&#39; }
    console.log(arguments.callee); // [Function: child]
    console.log(child.caller); // [Function: parent]
}

parent(&#39;mqin1&#39;, &#39;mqin2&#39;, &#39;mqin3&#39;);
&lt;/pre&gt;
</description>
        </item>
        
    </channel>
</rss>
