<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0">
    <channel>
        <title>RSS feed title</title>
        <link>Homepage link</link>
        <description>RSS feed description</description>
        <lastBuildDate>Mon, 27 Jan 2020 23:09:38 +0800</lastBuildDate>
        <language>zh-cn</language>
        
        <item>
            <title>Node.js 简介</title>
            <link>Homepage link/articles/nodejs.html?utm_source=rss&amp;utm_medium=rss&amp;utm_campaign=rss</link>
            <guid>Homepage link/articles/nodejs.html</guid>
            <author>Your E-mail Your name</author>
            <pubDate>Sun, 26 Jan 2020 00:00:00 +0800</pubDate>
            <description>&lt;h3 id=&quot;nodejs&quot;&gt;Node.js&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。 Node.js 使用了一个事件驱动、非阻塞式 I/O 的模型。 &lt;/li&gt;
&lt;li&gt;Node 是一个让 JavaScript 运行在服务端的开发平台，它让 JavaScript 成为与PHP、Python、Perl、Ruby 等服务端语言平起平坐的脚本语言。 发布于2009年5月，由Ryan Dahl开发，实质是对Chrome V8引擎进行了封装。&lt;/li&gt;
&lt;li&gt;Node对一些特殊用例进行优化，提供替代的API，使得V8在非浏览器环境下运行得更好。V8引擎执行Javascript的速度非常快，性能非常好。Node是一个基于Chrome JavaScript运行时建立的平台， 用于方便地搭建响应速度快、易于扩展的网络应用。Node 使用事件驱动， 非阻塞I/O 模型而得以轻量和高效，非常适合在分布式设备上运行数据密集型的实时应用。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;发展史&quot;&gt;发展史&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;2009年2月，Ryan Dahl在博客上宣布准备基于V8创建一个轻量级的Web服务器并提供一套库。&lt;/li&gt;
&lt;li&gt;2009年5月，Ryan Dahl在GitHub上发布了最初版本的部分Node包，随后几个月里，有人开始使用Node开发应用。&lt;/li&gt;
&lt;li&gt;2009年11月和2010年4月，两届JSConf大会都安排了Node.js的讲座。&lt;/li&gt;
&lt;li&gt;2010年年底，Node获得云计算服务商Joyent资助，创始人Ryan Dahl加入Joyent全职负责Node的发展。&lt;/li&gt;
&lt;li&gt;2011年7月，Node在微软的支持下发布Windows版本。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;特性&quot;&gt;特性&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;V8引擎本身使用了一些最新的编译技术。这使得用Javascript这类脚本语言编写出来的代码运行速度获得了极大提升，又节省了开发成本。对性能的苛求是Node的一个关键因素。 Javascript是一个事件驱动语言，Node利用了这个优点，编写出可扩展性高的服务器。Node采用了一个称为“事件循环(event loop）”的架构，使得编写可扩展性高的服务器变得既容易又安全。提高服务器性能的技巧有多种多样。Node选择了一种既能提高性能，又能减低开发复杂度的架构。这是一个非常重要的特性。并发编程通常很复杂且布满地雷。Node绕过了这些，但仍提供很好的性能。
Node采用一系列“非阻塞”库来支持事件循环的方式。本质上就是为文件系统、数据库之类的资源提供接口。向文件系统发送一个请求时，无需等待硬盘（寻址并检索文件），硬盘准备好的时候非阻塞接口会通知Node。该模型以可扩展的方式简化了对慢资源的访问， 直观，易懂。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;适用场景&quot;&gt;适用场景&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Node.js适合做一些高并发的，I/O密集型的应用。&lt;/li&gt;
&lt;li&gt;当应用程序需要处理大量并发的I/O，而在向客户端发出响应之前，应用程序内部并不需要进行非常复杂的处理的时候，Node.js非常适合。Node.js也非常适合与web socket配合，开发长连接的实时交互应用程序。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;nodejs优点&quot;&gt;Node.js优点&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;采用事件驱动、异步编程，为网络服务而设计。其实Javascript的匿名函数和闭包特性非常适合事件驱动、异步编程。而且JavaScript也简单易学，很多前端设计人员可以很快上手做后端设计。&lt;/li&gt;
&lt;li&gt;Node.js非阻塞模式的IO处理给Node.js带来在相对低系统资源耗用下的高性能与出众的负载能力，非常适合用作依赖其它IO资源的中间层服务。&lt;/li&gt;
&lt;li&gt;Node.js轻量高效，可以认为是数据密集型分布式部署环境下的实时应用系统的完美解决方案。Node非常适合如下情况：在响应客户端之前，您预计可能有很高的流量，但所需的服务器端逻辑和处理不一定很多。&lt;/li&gt;
&lt;li&gt;单进程，节约资源&lt;/li&gt;
&lt;li&gt;异步I/O，提升并发量&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;nodejs缺点&quot;&gt;Node.js缺点&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;可靠性低, 一旦出现未捕获的异常将直接导致服务不可用.&lt;/li&gt;
&lt;li&gt;单进程，单线程，只支持单核CPU，不能充分的利用多核CPU服务器。一旦这个进程崩掉，那么整个web服务就崩掉了。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;以上缺点可以可以通过代码的健壮性来弥补。使用cluster模式开启多个进程。 设置全局异常捕获器。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        </item>
        
        <item>
            <title>Node.js 模块</title>
            <link>Homepage link/articles/node-module.html?utm_source=rss&amp;utm_medium=rss&amp;utm_campaign=rss</link>
            <guid>Homepage link/articles/node-module.html</guid>
            <author>Your E-mail Your name</author>
            <pubDate>Mon, 27 Jan 2020 00:00:00 +0800</pubDate>
            <description>&lt;h3 id=&quot;nodejs-模块&quot;&gt;Node.js 模块&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;在 Node.js 模块系统中，每个文件都被视为一个独立的模块&lt;/li&gt;
&lt;li&gt;Node.js 模块机制采用了 Commonjs 规范，弥补了当前 JavaScript 开发大型应用没有标准的缺陷，类似于 Java 中的类文件，Python 中的 import 机制，Node.js 中可以通过 module.exports、require 来导出和引入一个模块.&lt;/li&gt;
&lt;li&gt;在模块加载机制中，Node.js 采用了延迟加载的策略，只有在用到的情况下，系统模块才会被加载，加载完成后会放到 binding_cache 中。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&nbsp;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&nbsp;&lt;/p&gt;
&lt;h3 id=&quot;模块的分类&quot;&gt;模块的分类&lt;/h3&gt;
&lt;h4 id=&quot;-emsp-系统模块&quot;&gt;&emsp;系统模块&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;C/C++ 模块，也叫 built-in 内建模块，一般用于 native 模块调用，在 require 出去&lt;/li&gt;
&lt;li&gt;native 模块，在开发中使用的 Node.js 的 http、buffer、fs 等，底层也是调用的内建模块 (C/C++)。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;-emsp-第三方模块&quot;&gt;&emsp;第三方模块&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;非 Node.js 自带的模块称为第三方模块，其实还分为路径形式的文件模块（以 &lt;code&gt;.&lt;/code&gt;、&lt;code&gt;..&lt;/code&gt;、&lt;code&gt;/&lt;/code&gt; 开头的）和自定义的模块（比如 express、koa 框架、moment.js 等）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;javaScript 模块：例如 &lt;code&gt;hello.js&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;json 模块：例如 &lt;code&gt;hello.json&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;C/C++ 模块：编译之后扩展名为 .node 的模块，例如 &lt;code&gt;hello.node&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;-emsp-目录结构&quot;&gt;&emsp;目录结构&lt;/h4&gt;
&lt;pre class=&quot;prettyprint linenums lang-js&quot;&gt;  ├── benchmark                         一些 Node.js 性能测试代码
  ├── deps                              Node.js 依赖
  ├── doc                               文档
  ├── lib                               Node.js 对外暴露的 js 模块源码
  ├── src                               Node.js 的 c/c++ 源码文件，内建模块
  ├── test                              单元测试
  ├── tools                             编译时用到的工具
  ├── doc                               api 文档
  ├── vcbuild.bat                       win 平台 makefile 文件
  ├── node.gyp                          node-gyp 构建编译任务的配置文件               
&lt;/pre&gt;
&lt;p&gt;&nbsp;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&nbsp;&lt;/p&gt;
&lt;h3 id=&quot;模块加载机制&quot;&gt;模块加载机制&lt;/h3&gt;
&lt;p&gt;&emsp;在 Node.js 中模块加载一般会经历 3 个步骤，&lt;code&gt;路径分析&lt;/code&gt;、&lt;code&gt;文件定位&lt;/code&gt;、&lt;code&gt;编译执行&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&emsp;按照模块的分类，按照以下顺序进行优先加载：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;系统缓存&lt;/strong&gt;：模块被执行之后会会进行缓存，首先是先进行缓存加载，判断缓存中是否有值。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;系统模块&lt;/strong&gt;：也就是原生模块，这个优先级仅次于缓存加载，部分核心模块已经被编译成二进制，省略了 &lt;code&gt;路径分析&lt;/code&gt;、&lt;code&gt;文件定位&lt;/code&gt;，直接加载到了内存中，系统模块定义在 Node.js 源码的 lib 目录下，可以去查看。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;文件模块&lt;/strong&gt;：优先加载 &lt;code&gt;.&lt;/code&gt;、&lt;code&gt;..&lt;/code&gt;、&lt;code&gt;/&lt;/code&gt; 开头的，如果文件没有加上扩展名，会依次按照 &lt;code&gt;.js&lt;/code&gt;、&lt;code&gt;.json&lt;/code&gt;、&lt;code&gt;.node&lt;/code&gt; 进行扩展名补足尝试，那么&lt;strong&gt;在尝试的过程中也是以同步阻塞模式来判断文件是否存在&lt;/strong&gt;，从性能优化的角度来看待，&lt;code&gt;.json&lt;/code&gt;、&lt;code&gt;.node&lt;/code&gt;最好还是加上文件的扩展名。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;目录做为模块&lt;/strong&gt;：这种情况发生在文件模块加载过程中，也没有找到，但是发现是一个目录的情况，这个时候会将这个目录当作一个 &lt;code&gt;包&lt;/code&gt; 来处理，Node 这块采用了 Commonjs 规范，先会在项目根目录查找 package.json 文件，取出文件中定义的 main 属性 &lt;code&gt;(&quot;main&quot;: &quot;lib/hello.js&quot;)&lt;/code&gt; 描述的入口文件进行加载，也没加载到，则会抛出默认错误: Error: Cannot find module &#39;lib/hello.js&#39;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;node_modules 目录加载&lt;/strong&gt;：对于系统模块、路径文件模块都找不到，Node.js 会从当前模块的父目录进行查找，直到系统的根目录&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&nbsp;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&nbsp;&lt;/p&gt;
&lt;h3 id=&quot;模块缓存&quot;&gt;模块缓存&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;模块在第一次加载后会被缓存。 这也意味着（类似其他缓存机制）如果每次调用 require(&#39;foo&#39;) 都解析到同一文件，则返回相同的对象。&lt;/li&gt;
&lt;li&gt;多次调用 require(foo) 不会导致模块的代码被执行多次。 这是一个重要的特性。 借助它, 可以返回“部分完成”的对象，从而允许加载依赖的依赖, 即使它们会导致循环依赖。&lt;/li&gt;
&lt;li&gt;如果想要多次执行一个模块，可以导出一个函数，然后调用该函数。&lt;/li&gt;
&lt;li&gt;Node.js 提供了 require.cache API 查看已缓存的模块，返回值为对象.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&emsp;为了验证，这里做一个简单的测试，如下所示：&lt;/p&gt;
&lt;p&gt;&emsp;&lt;strong&gt;新建 test-module.js 文件&lt;/strong&gt;
&emsp;这里我导出一个变量和一个方法&lt;/p&gt;
&lt;pre class=&quot;prettyprint linenums lang-js&quot;&gt;module.exports = {
    a: 1,
    test: () =&gt; {}
}
&lt;/pre&gt;
&lt;p&gt;&emsp;&lt;strong&gt;新建 test.js 文件&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;prettyprint linenums lang-js&quot;&gt;require(&#39;./test-module.js&#39;);

console.log(require.cache);
&lt;/pre&gt;
&lt;p&gt;在这个文件里加载 test-module.js 文件，在之后打印下 require.cache 看下里面返回的是什么？看到以下结果应该就很清晰了，模块的文件名、地址、导出数据都很清楚。&lt;/p&gt;
&lt;p&gt;&nbsp;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&nbsp;&lt;/p&gt;
&lt;h3 id=&quot;模块循环引用&quot;&gt;模块循环引用&lt;/h3&gt;
&lt;p&gt;&emsp;当循环调用 require() 时，一个模块可能在未完成执行时被返回。&lt;/p&gt;
&lt;p&gt;&emsp;例如以下情况:&lt;/p&gt;
&lt;p&gt;&emsp;a.js:&lt;/p&gt;
&lt;pre class=&quot;prettyprint linenums lang-js&quot;&gt;console.log(&#39;a 开始&#39;);
exports.done = false;
const b = require(&#39;./b.js&#39;);
console.log(&#39;在 a 中，b.done = %j&#39;, b.done);
exports.done = true;
console.log(&#39;a 结束&#39;);
&lt;/pre&gt;
&lt;p&gt;&emsp;b.js:&lt;/p&gt;
&lt;pre class=&quot;prettyprint linenums lang-js&quot;&gt;console.log(&#39;b 开始&#39;);
exports.done = false;
const a = require(&#39;./a.js&#39;);
console.log(&#39;在 b 中，a.done = %j&#39;, a.done);
exports.done = true;
console.log(&#39;b 结束&#39;);
&lt;/pre&gt;
&lt;p&gt;&emsp;main.js:&lt;/p&gt;
&lt;pre class=&quot;prettyprint linenums lang-js&quot;&gt;console.log(&#39;main 开始&#39;);
const a = require(&#39;./a.js&#39;);
const b = require(&#39;./b.js&#39;);
console.log(&#39;在 main 中，a.done=%j，b.done=%j&#39;, a.done, b.done);
&lt;/pre&gt;
&lt;p&gt;当 main.js 加载 a.js 时， a.js 又加载 b.js。 此时， b.js 会尝试去加载 a.js。 为了防止无限的循环，会返回一个 a.js 的 exports 对象的 未完成的副本 给 b.js 模块。 然后 b.js 完成加载，并将 exports 对象提供给 a.js 模块。&lt;/p&gt;
&lt;p&gt;当 main.js 加载这两个模块时，它们都已经完成加载。 因此，该程序的输出会是：&lt;/p&gt;
&lt;pre class=&quot;prettyprint linenums lang-js&quot;&gt;$ node main.js
main 开始
a 开始
b 开始
在 b 中，a.done = false
b 结束
在 a 中，b.done = true
a 结束
在 main 中，a.done=true，b.done=true
&lt;/pre&gt;
</description>
        </item>
        
        <item>
            <title>JavaScript 简介</title>
            <link>Homepage link/articles/javascript.html?utm_source=rss&amp;utm_medium=rss&amp;utm_campaign=rss</link>
            <guid>Homepage link/articles/javascript.html</guid>
            <author>Your E-mail Your name</author>
            <pubDate>Mon, 27 Jan 2020 00:00:00 +0800</pubDate>
            <description>&lt;h3 id=&quot;javascript-简介&quot;&gt;Javascript 简介&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;JavaScript（简称“JS”） 是一种具有函数优先的轻量级，解释型或即时编译型的编程语言。虽然它是作为开发Web页面的脚本语言而出名的，但是它也被用到了很多非浏览器环境中，JavaScript 基于原型编程、多范式的动态脚本语言，并且支持面向对象、命令式和声明式（如函数式编程）风格。&lt;/li&gt;
&lt;li&gt;JavaScript在1995年由Netscape公司的Brendan Eich，在网景导航者浏览器上首次设计实现而成。因为Netscape与Sun合作，Netscape管理层希望它外观看起来像Java，因此取名为JavaScript。但实际上它的语法风格与Self及Scheme较为接近。&lt;/li&gt;
&lt;li&gt;JavaScript的标准是ECMAScript 。截至 2012 年，所有浏览器都完整的支持ECMAScript 5.1，旧版本的浏览器至少支持ECMAScript 3 标准。2015年6月17日，ECMA国际组织发布了ECMAScript 的第六版，该版本正式名称为 ECMAScript 2015，但通常被称为ECMAScript 6 或者ES6。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;基本特点&quot;&gt;基本特点&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;JavaScript是一种属于网络的脚本语言,已经被广泛用于Web应用开发,常用来为网页添加各式各样的动态功能,为用户提供更流畅美观的浏览效果。通常JavaScript脚本是通过嵌入在HTML中来实现自身的功能的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;是一种解释性脚本语言（代码不进行预编译）。 &lt;/li&gt;
&lt;li&gt;主要用来向HTML（标准通用标记语言下的一个应用）页面添加交互行为。 &lt;/li&gt;
&lt;li&gt;可以直接嵌入HTML页面，但写成单独的js文件有利于结构和行为的分离。 &lt;/li&gt;
&lt;li&gt;跨平台特性，在绝大多数浏览器的支持下，可以在多种平台下运行（如Windows、Linux、Mac、Android、iOS等）。&lt;/li&gt;
&lt;li&gt;Javascript脚本语言同其他语言一样，有它自身的基本数据类型，表达式和算术运算符及程序的基本程序框架。Javascript提供了四种基本的数据类型和两种特殊数据类型用来处理数据和文字。而变量提供存放信息的地方，表达式则可以完成较复杂的信息处理。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;历史&quot;&gt;历史&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;它最初由Netscape的Brendan Eich设计。JavaScript是甲骨文公司的注册商标。Ecma国际以JavaScript为基础制定了ECMAScript标准。JavaScript也可以用于其他场合，如服务器端编程。完整的JavaScript实现包含三个部分：ECMAScript，文档对象模型，浏览器对象模型。  &lt;/li&gt;
&lt;li&gt;Netscape在最初将其脚本语言命名为LiveScript，后来Netscape在与Sun合作之后将其改名为JavaScript。JavaScript最初受Java启发而开始设计的，目的之一就是“看上去像Java”，因此语法上有类似之处，一些名称和命名规范也借自Java。但JavaScript的主要设计原则源自Self和Scheme。JavaScript与Java名称上的近似，是当时Netscape为了营销考虑与Sun微系统达成协议的结果。为了取得技术优势，微软推出了JScript来迎战JavaScript的脚本语言。为了互用性，Ecma国际（前身为欧洲计算机制造商协会）创建了ECMA-262标准（ECMAScript）。两者都属于ECMAScript的实现。尽管JavaScript作为给非程序人员的脚本语言，而非作为给程序人员的脚本语言来推广和宣传，但是JavaScript具有非常丰富的特性。 &lt;/li&gt;
&lt;li&gt;发展初期，JavaScript的标准并未确定，同期有Netscape的JavaScript，微软的JScript和CEnvi的ScriptEase三足鼎立。1997年，在ECMA（欧洲计算机制造商协会）的协调下，由Netscape、Sun、微软、Borland组成的工作组确定统一标准：ECMA-262。&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        
        <item>
            <title>JavaScript 类型</title>
            <link>Homepage link/articles/javascript-type.html?utm_source=rss&amp;utm_medium=rss&amp;utm_campaign=rss</link>
            <guid>Homepage link/articles/javascript-type.html</guid>
            <author>Your E-mail Your name</author>
            <pubDate>Tue, 28 Jan 2020 00:00:00 +0800</pubDate>
            <description>&lt;h3 id=&quot;javascript-类型&quot;&gt;JavaScript 类型&lt;/h3&gt;
&lt;h3 id=&quot;原始类型与引用类型&quot;&gt;原始类型与引用类型&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;JavaScript原始类型: Undefined、Null、Boolean、Number、String、Symbol &lt;/li&gt;
&lt;li&gt;JavaScript引用类型: Object &lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;原始类型-基础类型-&quot;&gt;原始类型(基础类型)&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;原始类型&lt;/strong&gt;又被称为&lt;strong&gt;基本类型&lt;/strong&gt;，原始类型保存的变量和值直接保存在&lt;strong&gt;栈内存&lt;/strong&gt;(Stack)中,且空间相互独立,通过值来访问&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class=&quot;prettyprint linenums lang-js&quot;&gt;let name = &#39;jane&#39;;
let name1 = name;

console.log(name === name1);//true

name = &#39;tom&#39;;
console.log(name);//tome
console.log(name1);//jane
&lt;/pre&gt;
&lt;p&gt;可以看到name的值虽然改变，但是name1的值是独立存储的所以不受影响&lt;/p&gt;
&lt;p&gt;虽然原始类型的值是储存在相对独立空间,但是它们之间的比较是按值比较的.&lt;/p&gt;
&lt;p&gt;&nbsp;&lt;/p&gt;
&lt;h4 id=&quot;引用类型&quot;&gt;引用类型&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;引用类型,即Object 类型,再往下细分，还可以分为：Object 类型、Array 类型、Date 类型、Function 类型 等。&lt;/li&gt;
&lt;li&gt;与原始类型不同的是,引用类型的内容是保存在&lt;strong&gt;堆内存&lt;/strong&gt;中,而&lt;strong&gt;栈内存&lt;/strong&gt;(Heap)中会有一个&lt;strong&gt;堆内存地址&lt;/strong&gt;,通过这个地址变量被指向堆内存中&lt;code&gt;Object&lt;/code&gt;真正的值,因此引用类型是按照引用访问的.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class=&quot;prettyprint linenums lang-js&quot;&gt;let person1 = { name: &quot;tome&quot;, age: 20 };
let person2 = person1;

person1.name = &quot;jane&quot;;
console.log(person2.name);    // jane
person2.age = 22;
console.log(person1.age);     // 22
var person3 = {
    name: &quot;jane&quot;,
    age: 22
};
console.log(person1 === person3); //false

&lt;/pre&gt;
&lt;p&gt;person1和person2两个变量指向了同一个对象。因此，改变其中任何一个变量，都会相互影响&lt;/p&gt;
&lt;p&gt;person3是新建了一个对象, 在堆内存中确实两个相互独立的Object,引用类型是按照引用比较,由于person1和person3引用的是不同的Object所以得到的结果是fasle.&lt;/p&gt;
&lt;p&gt;&emsp;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&emsp;&lt;/p&gt;
&lt;h3 id=&quot;类型中的坑&quot;&gt;类型中的坑&lt;/h3&gt;
&lt;h4 id=&quot;1-稀疏数组-指的是含有空白或空缺单元的数组&quot;&gt;1. 稀疏数组:指的是含有空白或空缺单元的数组&lt;/h4&gt;
&lt;pre class=&quot;prettyprint linenums lang-js&quot;&gt;let arr = [];
console.log(arr.length); //0

arr[4] = arr[5];
console.log(arr.length); //5

arr.forEach(elem =&gt; {
  console.log(elem); //undefined
});
console.log(arr); //[,,,,undefined]
&lt;/pre&gt;
&lt;p&gt;这里有几个坑需要注意:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;开始建立的空数组a的长度为0,这可以理解,但是在a[4] = a[5]之后出现了问题,a的长度居然变成了5,此时a数组是[,,,,undefined]这种形态.&lt;/li&gt;
&lt;li&gt;我们通过遍历,只得到了undefined这一个值,这个undefind是由于a[4] = a[5]赋值,由于a[5]没有定义值为undefined被赋给了a[4],可以等价为a[4] = undefined.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;2-字符串索引&quot;&gt;2. 字符串索引&lt;/h4&gt;
&lt;pre class=&quot;prettyprint linenums lang-js&quot;&gt;let a = [];
a[0] = 1;
a[&#39;name&#39;] = &#39;tom&#39;;
console.log(a.length); //1
console.log(a[&#39;name&#39;]); //tom
console.log(a); //[ 1, name: &#39;tom&#39; ]
&lt;/pre&gt;
&lt;p&gt;数组不仅可以通过数字索引,也可以通过字符串索引,但值得注意的是,字符串索引的键值对并不算在数组的长度里.&lt;/p&gt;
&lt;h4 id=&quot;3-数字中的坑-二进制浮点数&quot;&gt;3. 数字中的坑 二进制浮点数&lt;/h4&gt;
&lt;p&gt;JavaScript 中的数字类型是基于“二进制浮点数”实现的,使用的是“双精度”格式,这就带来了一些反常的问题,我们那一道经典面试提来讲解下.&lt;/p&gt;
&lt;pre class=&quot;prettyprint linenums lang-js&quot;&gt;let a = 0.1 + 0.2;
let b = 0.3;
console.log(a === b); //false
&lt;/pre&gt;
&lt;p&gt;这是个出人意料的结果,实际上a的值约为0.30000000000000004这并不是一个整数值,这就是二进制浮点数带来的副作用.&lt;/p&gt;
&lt;pre class=&quot;prettyprint linenums lang-js&quot;&gt;let a = 0.1 + 0.2;
let b = 0.3;
console.log(a === b); //false
console.log(Number.isInteger(a*10)); //false
console.log(Number.isInteger(b*10)); //true
console.log(a); //0.30000000000000004
&lt;/pre&gt;
&lt;p&gt;我们可以用Number.isInteger()来判断一个数字是否为整数.&lt;/p&gt;
&lt;h4 id=&quot;4-nan&quot;&gt;4. NaN&lt;/h4&gt;
&lt;pre class=&quot;prettyprint linenums lang-js&quot;&gt;let a = 1/new Object();
console.log(typeof a); //Number
console.log(a); //NaN
console.log(isNaN(a)); //true
&lt;/pre&gt;
&lt;p&gt;NaN属于特殊的Number类型,我们可以把它理解为坏数值,因为它属于数值计算中的错误,更加特殊的是它自己都不等价于自己NaN === NaN //false,我们只能用isNaN()来检测一个数字是否为NaN.&lt;/p&gt;
&lt;p&gt;&emsp;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&emsp;&lt;/p&gt;
&lt;h3 id=&quot;类型判断&quot;&gt;类型判断&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;类型检测主要包括了: typeof、instanceof和toString的三种方式来判断变量的类型。&lt;/li&gt;
&lt;li&gt;typeof: 用来检测基本类型&lt;/li&gt;
&lt;li&gt;toString: typeof的增强,用来判断内置的数据类型,无法判断自己构造的对象.&lt;/li&gt;
&lt;li&gt;instanceof: 用来检测是否为数组、对象、正则&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;typeof&quot;&gt;typeof&lt;/h4&gt;
&lt;p&gt;typeof接受一个值并返回它的类型，它有两种可能的语法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;typeof x&lt;/li&gt;
&lt;li&gt;typeof(x)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当在primitive类型上使用typeof检测变量类型时，我们总能得到我们想要的结果，比如&lt;/p&gt;
&lt;pre class=&quot;prettyprint linenums lang-js&quot;&gt;typeof 1; // &quot;number&quot;
typeof &quot;&quot;; // &quot;string&quot;
typeof true; // &quot;boolean&quot;
typeof bla; // &quot;undefined&quot;
typeof undefined; // &quot;undefined&quot;
&lt;/pre&gt;
&lt;p&gt;而当在object类型上使用typeof检测时，有时可能并不能得到你想要的结果，比如：&lt;/p&gt;
&lt;pre class=&quot;prettyprint linenums lang-js&quot;&gt;typeof []; // &quot;object&quot;
typeof null; // &quot;object&quot;
typeof /regex/ // &quot;object&quot;
typeof new String(&quot;&quot;); // &quot;object&quot;
typeof function(){}; // &quot;function&quot;
&lt;/pre&gt;
&lt;p&gt;这里的[]返回的确却是object，这可能并不是你想要的，因为数组是一个特殊的对象，有时候这可能并不是你想要的结果。&lt;/p&gt;
&lt;p&gt;对于这里的null返回的确却是object，wtf，有些人说null被认为是没有一个对象。&lt;/p&gt;
&lt;p&gt;当你对于typeof检测数据类型不确定时，请谨慎使用。&lt;/p&gt;
&lt;h4 id=&quot;tostring&quot;&gt;toString&lt;/h4&gt;
&lt;p&gt;toString不管是对于object类型还是primitive类型，都能得到你想要的结果：&lt;/p&gt;
&lt;pre class=&quot;prettyprint linenums lang-js&quot;&gt;let toClass = {}.toString;

console.log(toClass.call(123));
console.log(toClass.call(true));
console.log(toClass.call(Symbol(&#39;foo&#39;)));
console.log(toClass.call(&#39;some string&#39;));
console.log(toClass.call([1, 2]));
console.log(toClass.call(new Date()));
console.log(toClass.call({
    a: &#39;a&#39;
}));

// output
[object Number]
[object Boolean]
[object Symbol]
[object String]
[object Array]
[object Date]
[object Object]
&lt;/pre&gt;
&lt;h4 id=&quot;instanceof&quot;&gt;instanceof&lt;/h4&gt;
&lt;p&gt;对于使用构造函数创建的对象，我们通常使用instanceof来判断某一实例是否属于某种类型，例如：a instanceof Person，其内部原理实际上是判断Person.prototype是否在a实例的原型链中，其原理可以用下面的函数来表达：&lt;/p&gt;
&lt;pre class=&quot;prettyprint linenums lang-js&quot;&gt;function instance_of(V, F) {
  let O = F.prototype;
  V = V.__proto__;
  while (true) {
    if (V === null)
      return false;
    if (O === V)
      return true;
    V = V.__proto__;
  }
}

// use
function Person() {
}
let a = new Person();

// true
console.log(instance_of(a, Person));
&lt;/pre&gt;
</description>
        </item>
        
    </channel>
</rss>
