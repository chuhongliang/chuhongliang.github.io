<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0">
    <channel>
        <title>RSS feed title</title>
        <link>Homepage link</link>
        <description>RSS feed description</description>
        <lastBuildDate>Mon, 27 Jan 2020 12:19:47 +0800</lastBuildDate>
        <language>zh-cn</language>
        
        <item>
            <title>Node.js 简介</title>
            <link>Homepage link/articles/nodejs.html?utm_source=rss&amp;utm_medium=rss&amp;utm_campaign=rss</link>
            <guid>Homepage link/articles/nodejs.html</guid>
            <author>Your E-mail Your name</author>
            <pubDate>Sun, 26 Jan 2020 00:00:00 +0800</pubDate>
            <description>&lt;h3 id=&quot;nodejs&quot;&gt;Node.js&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;2009年5月 由 Ryan Dahl 发布&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。 Node.js 使用了一个事件驱动、非阻塞式 I/O 的模型。 [1] &lt;/li&gt;
&lt;li&gt;Node 是一个让 JavaScript 运行在服务端的开发平台，它让 JavaScript 成为与PHP、Python、Perl、Ruby 等服务端语言平起平坐的脚本语言。 [2]  发布于2009年5月，由Ryan Dahl开发，实质是对Chrome V8引擎进行了封装。&lt;/li&gt;
&lt;li&gt;Node对一些特殊用例进行优化，提供替代的API，使得V8在非浏览器环境下运行得更好。V8引擎执行Javascript的速度非常快，性能非常好。Node是一个基于Chrome JavaScript运行时建立的平台， 用于方便地搭建响应速度快、易于扩展的网络应用。Node 使用事件驱动， 非阻塞I/O 模型而得以轻量和高效，非常适合在分布式设备上运行数据密集型的实时应用。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;发展史&quot;&gt;发展史&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;2009年2月，Ryan Dahl在博客上宣布准备基于V8创建一个轻量级的Web服务器并提供一套库。&lt;/li&gt;
&lt;li&gt;2009年5月，Ryan Dahl在GitHub上发布了最初版本的部分Node包，随后几个月里，有人开始使用Node开发应用。&lt;/li&gt;
&lt;li&gt;2009年11月和2010年4月，两届JSConf大会都安排了Node.js的讲座。&lt;/li&gt;
&lt;li&gt;2010年年底，Node获得云计算服务商Joyent资助，创始人Ryan Dahl加入Joyent全职负责Node的发展。&lt;/li&gt;
&lt;li&gt;2011年7月，Node在微软的支持下发布Windows版本。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;特性&quot;&gt;特性&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;V8引擎本身使用了一些最新的编译技术。这使得用Javascript这类脚本语言编写出来的代码运行速度获得了极大提升，又节省了开发成本。对性能的苛求是Node的一个关键因素。 Javascript是一个事件驱动语言，Node利用了这个优点，编写出可扩展性高的服务器。Node采用了一个称为“事件循环(event loop）”的架构，使得编写可扩展性高的服务器变得既容易又安全。提高服务器性能的技巧有多种多样。Node选择了一种既能提高性能，又能减低开发复杂度的架构。这是一个非常重要的特性。并发编程通常很复杂且布满地雷。Node绕过了这些，但仍提供很好的性能。
Node采用一系列“非阻塞”库来支持事件循环的方式。本质上就是为文件系统、数据库之类的资源提供接口。向文件系统发送一个请求时，无需等待硬盘（寻址并检索文件），硬盘准备好的时候非阻塞接口会通知Node。该模型以可扩展的方式简化了对慢资源的访问， 直观，易懂。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;适用场景&quot;&gt;适用场景&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Node.js适合做一些高并发的，I/O密集型的应用。&lt;/li&gt;
&lt;li&gt;当应用程序需要处理大量并发的I/O，而在向客户端发出响应之前，应用程序内部并不需要进行非常复杂的处理的时候，Node.js非常适合。Node.js也非常适合与web socket配合，开发长连接的实时交互应用程序。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;nodejs优点&quot;&gt;Node.js优点&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;采用事件驱动、异步编程，为网络服务而设计。其实Javascript的匿名函数和闭包特性非常适合事件驱动、异步编程。而且JavaScript也简单易学，很多前端设计人员可以很快上手做后端设计。&lt;/li&gt;
&lt;li&gt;Node.js非阻塞模式的IO处理给Node.js带来在相对低系统资源耗用下的高性能与出众的负载能力，非常适合用作依赖其它IO资源的中间层服务。&lt;/li&gt;
&lt;li&gt;Node.js轻量高效，可以认为是数据密集型分布式部署环境下的实时应用系统的完美解决方案。Node非常适合如下情况：在响应客户端之前，您预计可能有很高的流量，但所需的服务器端逻辑和处理不一定很多。&lt;/li&gt;
&lt;li&gt;单进程，节约资源&lt;/li&gt;
&lt;li&gt;异步I/O，提升并发量&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;nodejs缺点&quot;&gt;Node.js缺点&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;可靠性低, 一旦出现未捕获的异常将直接导致服务不可用.&lt;/li&gt;
&lt;li&gt;单进程，单线程，只支持单核CPU，不能充分的利用多核CPU服务器。一旦这个进程崩掉，那么整个web服务就崩掉了。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;以上缺点可以可以通过代码的健壮性来弥补。使用cluster模式开启多个进程。 设置全局异常捕获器。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        </item>
        
        <item>
            <title>Node.js 模块</title>
            <link>Homepage link/articles/node-module.html?utm_source=rss&amp;utm_medium=rss&amp;utm_campaign=rss</link>
            <guid>Homepage link/articles/node-module.html</guid>
            <author>Your E-mail Your name</author>
            <pubDate>Mon, 27 Jan 2020 00:00:00 +0800</pubDate>
            <description>&lt;h3 id=&quot;nodejs-模块&quot;&gt;Node.js 模块&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;在 Node.js 模块系统中，每个文件都被视为一个独立的模块&lt;/li&gt;
&lt;li&gt;Node.js 模块机制采用了 Commonjs 规范，弥补了当前 JavaScript 开发大型应用没有标准的缺陷，类似于 Java 中的类文件，Python 中的 import 机制，Node.js 中可以通过 module.exports、require 来导出和引入一个模块.&lt;/li&gt;
&lt;li&gt;在模块加载机制中，Node.js 采用了延迟加载的策略，只有在用到的情况下，系统模块才会被加载，加载完成后会放到 binding_cache 中。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&nbsp;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&nbsp;&lt;/p&gt;
&lt;h3 id=&quot;模块的分类&quot;&gt;模块的分类&lt;/h3&gt;
&lt;h4 id=&quot;-emsp-系统模块&quot;&gt;&emsp;系统模块&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;C/C++ 模块，也叫 built-in 内建模块，一般用于 native 模块调用，在 require 出去&lt;/li&gt;
&lt;li&gt;native 模块，在开发中使用的 Node.js 的 http、buffer、fs 等，底层也是调用的内建模块 (C/C++)。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;-emsp-第三方模块&quot;&gt;&emsp;第三方模块&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;非 Node.js 自带的模块称为第三方模块，其实还分为路径形式的文件模块（以 &lt;code&gt;.&lt;/code&gt;、&lt;code&gt;..&lt;/code&gt;、&lt;code&gt;/&lt;/code&gt; 开头的）和自定义的模块（比如 express、koa 框架、moment.js 等）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;javaScript 模块：例如 &lt;code&gt;hello.js&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;json 模块：例如 &lt;code&gt;hello.json&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;C/C++ 模块：编译之后扩展名为 .node 的模块，例如 &lt;code&gt;hello.node&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;-emsp-目录结构&quot;&gt;&emsp;目录结构&lt;/h4&gt;
&lt;pre&gt;  ├── benchmark                         一些 Node.js 性能测试代码
  ├── deps                              Node.js 依赖
  ├── doc                               文档
  ├── lib                               Node.js 对外暴露的 js 模块源码
  ├── src                               Node.js 的 c/c++ 源码文件，内建模块
  ├── test                              单元测试
  ├── tools                             编译时用到的工具
  ├── doc                               api 文档
  ├── vcbuild.bat                       win 平台 makefile 文件
  ├── node.gyp                          node-gyp 构建编译任务的配置文件               
&lt;/pre&gt;&lt;p&gt;&nbsp;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&nbsp;&lt;/p&gt;
&lt;h3 id=&quot;模块加载机制&quot;&gt;模块加载机制&lt;/h3&gt;
&lt;p&gt;&emsp;在 Node.js 中模块加载一般会经历 3 个步骤，&lt;code&gt;路径分析&lt;/code&gt;、&lt;code&gt;文件定位&lt;/code&gt;、&lt;code&gt;编译执行&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&emsp;按照模块的分类，按照以下顺序进行优先加载：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;系统缓存&lt;/strong&gt;：模块被执行之后会会进行缓存，首先是先进行缓存加载，判断缓存中是否有值。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;系统模块&lt;/strong&gt;：也就是原生模块，这个优先级仅次于缓存加载，部分核心模块已经被编译成二进制，省略了 &lt;code&gt;路径分析&lt;/code&gt;、&lt;code&gt;文件定位&lt;/code&gt;，直接加载到了内存中，系统模块定义在 Node.js 源码的 lib 目录下，可以去查看。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;文件模块&lt;/strong&gt;：优先加载 &lt;code&gt;.&lt;/code&gt;、&lt;code&gt;..&lt;/code&gt;、&lt;code&gt;/&lt;/code&gt; 开头的，如果文件没有加上扩展名，会依次按照 &lt;code&gt;.js&lt;/code&gt;、&lt;code&gt;.json&lt;/code&gt;、&lt;code&gt;.node&lt;/code&gt; 进行扩展名补足尝试，那么&lt;strong&gt;在尝试的过程中也是以同步阻塞模式来判断文件是否存在&lt;/strong&gt;，从性能优化的角度来看待，&lt;code&gt;.json&lt;/code&gt;、&lt;code&gt;.node&lt;/code&gt;最好还是加上文件的扩展名。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;目录做为模块&lt;/strong&gt;：这种情况发生在文件模块加载过程中，也没有找到，但是发现是一个目录的情况，这个时候会将这个目录当作一个 &lt;code&gt;包&lt;/code&gt; 来处理，Node 这块采用了 Commonjs 规范，先会在项目根目录查找 package.json 文件，取出文件中定义的 main 属性 &lt;code&gt;(&quot;main&quot;: &quot;lib/hello.js&quot;)&lt;/code&gt; 描述的入口文件进行加载，也没加载到，则会抛出默认错误: Error: Cannot find module &#39;lib/hello.js&#39;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;node_modules 目录加载&lt;/strong&gt;：对于系统模块、路径文件模块都找不到，Node.js 会从当前模块的父目录进行查找，直到系统的根目录&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&nbsp;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&nbsp;&lt;/p&gt;
&lt;h3 id=&quot;模块缓存&quot;&gt;模块缓存&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;模块在第一次加载后会被缓存。 这也意味着（类似其他缓存机制）如果每次调用 require(&#39;foo&#39;) 都解析到同一文件，则返回相同的对象。&lt;/li&gt;
&lt;li&gt;多次调用 require(foo) 不会导致模块的代码被执行多次。 这是一个重要的特性。 借助它, 可以返回“部分完成”的对象，从而允许加载依赖的依赖, 即使它们会导致循环依赖。&lt;/li&gt;
&lt;li&gt;如果想要多次执行一个模块，可以导出一个函数，然后调用该函数。&lt;/li&gt;
&lt;li&gt;Node.js 提供了 require.cache API 查看已缓存的模块，返回值为对象.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&emsp;为了验证，这里做一个简单的测试，如下所示：&lt;/p&gt;
&lt;p&gt;&emsp;&lt;strong&gt;新建 test-module.js 文件&lt;/strong&gt;
&emsp;这里我导出一个变量和一个方法&lt;/p&gt;
&lt;pre class=&quot;prettyprint linenums lang-js&quot;&gt;module.exports = {
    a: 1,
    test: () =&gt; {}
}
&lt;/pre&gt;
&lt;p&gt;&emsp;&lt;strong&gt;新建 test.js 文件&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;prettyprint linenums lang-js&quot;&gt;require(&#39;./test-module.js&#39;);

console.log(require.cache);
&lt;/pre&gt;
&lt;p&gt;在这个文件里加载 test-module.js 文件，在之后打印下 require.cache 看下里面返回的是什么？看到以下结果应该就很清晰了，模块的文件名、地址、导出数据都很清楚。&lt;/p&gt;
&lt;p&gt;&nbsp;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&nbsp;&lt;/p&gt;
&lt;h3 id=&quot;模块循环引用&quot;&gt;模块循环引用&lt;/h3&gt;
&lt;p&gt;&emsp;当循环调用 require() 时，一个模块可能在未完成执行时被返回。&lt;/p&gt;
&lt;p&gt;&emsp;例如以下情况:&lt;/p&gt;
&lt;p&gt;&emsp;a.js:&lt;/p&gt;
&lt;pre class=&quot;prettyprint linenums lang-js&quot;&gt;console.log(&#39;a 开始&#39;);
exports.done = false;
const b = require(&#39;./b.js&#39;);
console.log(&#39;在 a 中，b.done = %j&#39;, b.done);
exports.done = true;
console.log(&#39;a 结束&#39;);
&lt;/pre&gt;
&lt;p&gt;&emsp;b.js:&lt;/p&gt;
&lt;pre class=&quot;prettyprint linenums lang-js&quot;&gt;console.log(&#39;b 开始&#39;);
exports.done = false;
const a = require(&#39;./a.js&#39;);
console.log(&#39;在 b 中，a.done = %j&#39;, a.done);
exports.done = true;
console.log(&#39;b 结束&#39;);
&lt;/pre&gt;
&lt;p&gt;&emsp;main.js:&lt;/p&gt;
&lt;pre class=&quot;prettyprint linenums lang-js&quot;&gt;console.log(&#39;main 开始&#39;);
const a = require(&#39;./a.js&#39;);
const b = require(&#39;./b.js&#39;);
console.log(&#39;在 main 中，a.done=%j，b.done=%j&#39;, a.done, b.done);
&lt;/pre&gt;
&lt;p&gt;当 main.js 加载 a.js 时， a.js 又加载 b.js。 此时， b.js 会尝试去加载 a.js。 为了&amp;防止无限的循环，会返回一个 a.js 的 exports 对象的 未完成的副本 给 b.js 模块。 然后 &amp;b.js 完成加载，并将 exports 对象提供给 a.js 模块。&lt;/p&gt;
&lt;p&gt;当 main.js 加载这两个模块时，它们都已经完成加载。 因此，该程序的输出会是：&lt;/p&gt;
&lt;pre class=&quot;prettyprint linenums lang-js&quot;&gt;$ node main.js
main 开始
a 开始
b 开始
在 b 中，a.done = false
b 结束
在 a 中，b.done = true
a 结束
在 main 中，a.done=true，b.done=true
&lt;/pre&gt;
</description>
        </item>
        
    </channel>
</rss>
